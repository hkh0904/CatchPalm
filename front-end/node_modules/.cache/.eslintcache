[{"C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\index.tsx":"1","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\reportWebVitals.ts":"2","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\App.tsx":"3","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\pages\\PlayingPage.tsx":"4","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\utils\\drawCanvas.ts":"5"},{"size":573,"mtime":1690439000508,"results":"6","hashOfConfig":"7"},{"size":440,"mtime":1690439000512,"results":"8","hashOfConfig":"7"},{"size":822,"mtime":1690439000506,"results":"9","hashOfConfig":"7"},{"size":5619,"mtime":1690439000511,"results":"10","hashOfConfig":"7"},{"size":925,"mtime":1690439000516,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1azhga0",{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","suppressedMessages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21"},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\index.tsx",[],[],"C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\reportWebVitals.ts",[],[],"C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\App.tsx",["29"],[],"import React from \"react\";\r\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\r\nimport { Routes, Route as NestedRoute } from \"react-router-dom\"; // react-router-dom에서 Routes와 NestedRoute를 가져옵니다.\r\nimport PlayingPage from \"./pages/PlayingPage\"; // PlayingPage 컴포넌트를 불러옵니다.\r\n\r\nconst MainPage = () => {\r\n  return (\r\n    <div>\r\n      <h1>메인 페이지</h1>\r\n      <Link to=\"/playingPage\">플레이 페이지로 이동</Link>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst App = () => {\r\n  return (\r\n    <Router>\r\n      {/* 메인 페이지와 PlayingPage를 라우팅합니다. */}\r\n      <Routes>\r\n        <Route path=\"/\" element={<MainPage />} />\r\n        <Route path=\"/playingPage\" element={<PlayingPage />} />\r\n      </Routes>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\pages\\PlayingPage.tsx",["30","31","32"],[],"import React, { useCallback, useEffect, useRef, useState } from \"react\";\r\nimport { Link, useNavigate } from \"react-router-dom\";\r\nimport Webcam from \"react-webcam\";\r\nimport { css } from \"@emotion/css\";\r\nimport { Camera } from \"@mediapipe/camera_utils\";\r\nimport { Hands, Results } from \"@mediapipe/hands\";\r\nimport { drawCanvas } from \"../utils/drawCanvas\";\r\n\r\nconst PlayingPage = () => {\r\n  const webcamRef = useRef<Webcam>(null);\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const resultsRef = useRef<Results>();\r\n  const navigate = useNavigate(); // useNavigate 훅을 이용하여 프로그래밍적으로 페이지를 이동할 수 있도록 가져옵니다.\r\n  const [jsonData, setJsonData] = useState<any[]>([]);\r\n\r\n  /**\r\n   * 검출결과（프레임마다 호출됨）\r\n   * @param results\r\n   */\r\n  const onResults = useCallback((results: Results) => {\r\n    resultsRef.current = results;\r\n\r\n    const canvasCtx = canvasRef.current!.getContext(\"2d\")!;\r\n    drawCanvas(canvasCtx, results);\r\n  }, []);\r\n\r\n  // 초기설정\r\n  useEffect(() => {\r\n    const hands = new Hands({\r\n      locateFile: (file) => {\r\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;\r\n      },\r\n    });\r\n\r\n    hands.setOptions({\r\n      maxNumHands: 2,\r\n      modelComplexity: 1,\r\n      minDetectionConfidence: 0.5,\r\n      minTrackingConfidence: 0.5,\r\n    });\r\n\r\n    hands.onResults(onResults);\r\n\r\n    if (webcamRef.current) {\r\n      const camera = new Camera(webcamRef.current.video!, {\r\n        onFrame: async () => {\r\n          await hands.send({ image: webcamRef.current!.video! });\r\n        },\r\n        width: window.innerWidth, // 사용자의 화면 가로 크기로 설정\r\n        height: window.innerHeight, // 사용자의 화면 세로 크기로 설정\r\n      });\r\n      camera.start();\r\n    }\r\n  }, [onResults]);\r\n\r\n\r\n  // PlayingPage가 언마운트(unmount)될 때 webcamRef를 해제합니다.\r\n  useEffect(() => {\r\n    return () => {\r\n      if (webcamRef.current && webcamRef.current.video) {\r\n        const videoElement = webcamRef.current.video;\r\n        const stream = videoElement.srcObject as MediaStream;\r\n        const tracks = stream?.getTracks();\r\n        if (tracks) {\r\n          tracks.forEach((track) => track.stop());\r\n        }\r\n        videoElement.srcObject = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  /* 랜드마크들의 좌표를 콘솔에 출력 */\r\n  const OutputData = () => {\r\n    const results = resultsRef.current!;\r\n    console.log(results.multiHandLandmarks);\r\n  };\r\n\r\n  const WebcamToggle = () => {\r\n\r\n  }\r\n\r\n  // 메인 페이지로 돌아가는 함수를 정의합니다.\r\n  const goBackToMainPage = () => {\r\n    navigate(\"/\");\r\n  };\r\n\r\n  // JSON 데이터를 가져오는 함수\r\n  const fetchData = async () => {\r\n    try {\r\n      const response = await fetch(\"/assets/YOASOBI-IDOL.json\"); // JSON 파일의 경로를 수정해주세요.\r\n      if (!response.ok) {\r\n        throw new Error(\"Network response was not ok\");\r\n      }\r\n      const jsonData: any[] = await response.json();\r\n      console.log(jsonData);\r\n      setJsonData(jsonData);\r\n    } catch (error) {\r\n      console.error(\"Error fetching JSON:\", error);\r\n    }\r\n  };\r\n\r\n  // 컴포넌트가 마운트될 때 JSON 데이터를 가져옵니다.\r\n  useEffect(() => {\r\n    fetchData();\r\n  }, []);\r\n\r\n  // jsonData를 이용하여 원하는 작업을 진행하시면 됩니다.\r\n\r\n  return (\r\n    <div className={styles.page}>\r\n      <div className={styles.container}>\r\n        {/* 비디오 캡쳐 */}\r\n        <Webcam\r\n          audio={false}\r\n          style={{ visibility: \"hidden\" }}\r\n          width={1280}\r\n          height={720}\r\n          ref={webcamRef}\r\n          screenshotFormat=\"image/jpeg\"\r\n          videoConstraints={{ width: 1280, height: 720, facingMode: \"user\" }}\r\n        />\r\n        {/* 랜드마크를 손에 표시 */}\r\n        <canvas\r\n          ref={canvasRef}\r\n          className={styles.canvas}\r\n          width={1280}\r\n          height={720}\r\n        />\r\n        {/* 좌표 출력 */}\r\n        <div className={styles.buttonContainer}>\r\n          <button className={styles.button} onClick={OutputData}>\r\n            Output Data\r\n          </button>\r\n          <button className={styles.button} onClick={WebcamToggle}>\r\n            WebCam ON/OFF\r\n          </button>\r\n          {/* 메인 페이지로 돌아가는 버튼 */}\r\n          <button className={styles.button} onClick={goBackToMainPage}>\r\n            메인 페이지\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div id=\"sidebar\" className={styles.sidebar}>\r\n        <p>사이드바 ( 다른플레이어 )</p>\r\n      </div>\r\n    </div>\r\n  );\r\n  \r\n};\r\n\r\n// ==============================================\r\n// styles\r\nconst styles = {\r\n  page: css`\r\n    display: flex;\r\n    width: 100vw;\r\n    height: 100vh;\r\n  `,\r\n  container: css`\r\n    position: relative;\r\n    width: 75vw;\r\n    height: 100vh;\r\n    overflow: hidden;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    margin-right: auto;\r\n  `,\r\n  sidebar: css`\r\n    width: 25vw;\r\n    height: 100vh;\r\n    /* 이곳에 빈 공간의 스타일을 추가하세요 */\r\n  `,\r\n\r\n  canvas: css`\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: #fff;\r\n  `,\r\n  buttonContainer: css`\r\n    position: absolute;\r\n    top: 20px;\r\n    left: 20px;\r\n  `,\r\n  button: css`\r\n    color: #fff;\r\n    background-color: #0082cf;\r\n    font-size: 1rem;\r\n    border: none;\r\n    border-radius: 5px;\r\n    padding: 10px 10px;\r\n    cursor: pointer;\r\n    margin-right: 10px;\r\n  `,\r\n};\r\n\r\nexport default PlayingPage;","C:\\Users\\SSAFY\\workspace\\catchpalm\\front-end\\src\\utils\\drawCanvas.ts",[],[],{"ruleId":"33","severity":1,"message":"34","line":3,"column":27,"nodeType":"35","messageId":"36","endLine":3,"endColumn":38},{"ruleId":"33","severity":1,"message":"37","line":2,"column":10,"nodeType":"35","messageId":"36","endLine":2,"endColumn":14},{"ruleId":"33","severity":1,"message":"38","line":14,"column":10,"nodeType":"35","messageId":"36","endLine":14,"endColumn":18},{"ruleId":"39","severity":1,"message":"40","line":61,"column":40,"nodeType":"35","endLine":61,"endColumn":47},"@typescript-eslint/no-unused-vars","'NestedRoute' is defined but never used.","Identifier","unusedVar","'Link' is defined but never used.","'jsonData' is assigned a value but never used.","react-hooks/exhaustive-deps","The ref value 'webcamRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'webcamRef.current' to a variable inside the effect, and use that variable in the cleanup function."]