{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalRecorder = void 0;\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar Mime = require(\"mime/lite\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Easy recording of {@link Stream} objects straightaway from the browser. Initialized with {@link OpenVidu.initLocalRecorder} method\n */\nvar LocalRecorder = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function LocalRecorder(stream) {\n    this.stream = stream;\n    this.chunks = [];\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n    this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n    this.state = LocalRecorderState_1.LocalRecorderState.READY;\n  }\n  /**\n   * Starts the recording of the Stream. {@link state} property must be `READY`. After method succeeds is set to `RECORDING`\n   *\n   * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n   * For example:\n   *\n   * ```javascript\n   * var OV = new OpenVidu();\n   * var publisher = await OV.initPublisherAsync();\n   * var localRecorder = OV.initLocalRecorder(publisher.stream);\n   * var options = {\n   *      mimeType: 'video/webm;codecs=vp8',\n   *      audioBitsPerSecond:128000,\n   *      videoBitsPerSecond:2500000\n   * };\n   * localRecorder.record(options);\n   * ```\n   *\n   * If not specified, the default options preferred by the platform will be used.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.record = function (options) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (typeof options === 'string' || options instanceof String) {\n          return reject(\"When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \\\"\".concat(options, \"\\\" }\"));\n        }\n        if (typeof MediaRecorder === 'undefined') {\n          logger.error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n          throw Error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n        }\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n          throw Error(\"'LocalRecord.record()' needs 'LocalRecord.state' to be 'READY' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.clean()' or init a new LocalRecorder before\");\n        }\n        logger.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n        if (!options) {\n          options = {\n            mimeType: 'video/webm'\n          };\n        } else if (!options.mimeType) {\n          options.mimeType = 'video/webm';\n        }\n        _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n        _this.mediaRecorder.start();\n      } catch (err) {\n        return reject(err);\n      }\n      _this.mediaRecorder.ondataavailable = function (e) {\n        if (e.data.size > 0) {\n          _this.chunks.push(e.data);\n        }\n      };\n      _this.mediaRecorder.onerror = function (e) {\n        logger.error('MediaRecorder error: ', e);\n      };\n      _this.mediaRecorder.onstart = function () {\n        logger.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.mediaRecorder.onstop = function () {\n        _this.onStopDefault();\n      };\n      _this.mediaRecorder.onpause = function () {\n        logger.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.mediaRecorder.onresume = function () {\n        logger.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      return resolve();\n    });\n  };\n  /**\n   * Ends the recording of the Stream. {@link state} property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.stop = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n          throw Error(\"'LocalRecord.stop()' needs 'LocalRecord.state' to be 'RECORDING' or 'PAUSED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.start()' before\");\n        }\n        _this.mediaRecorder.onstop = function () {\n          _this.onStopDefault();\n          return resolve();\n        };\n        _this.mediaRecorder.stop();\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\n   * Pauses the recording of the Stream. {@link state} property must be `RECORDING`. After method succeeds is set to `PAUSED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.pause = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n          return reject(Error(\"'LocalRecord.pause()' needs 'LocalRecord.state' to be 'RECORDING' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.start()' or 'LocalRecorder.resume()' before\"));\n        }\n        _this.mediaRecorder.pause();\n        _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Resumes the recording of the Stream. {@link state} property must be `PAUSED`. After method succeeds is set to `RECORDING`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.resume = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n          throw Error(\"'LocalRecord.resume()' needs 'LocalRecord.state' to be 'PAUSED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.pause()' before\");\n        }\n        _this.mediaRecorder.resume();\n        _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.preview = function (parentElement) {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"'LocalRecord.preview()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + this.state + \"'). Call 'LocalRecorder.stop()' before\");\n    }\n    this.videoPreview = document.createElement('video');\n    this.videoPreview.id = this.id;\n    this.videoPreview.autoplay = true;\n    if (platform.isSafariBrowser()) {\n      this.videoPreview.playsInline = true;\n    }\n    if (typeof parentElement === 'string') {\n      var parentElementDom = document.getElementById(parentElement);\n      if (parentElementDom) {\n        this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n      }\n    } else {\n      this.videoPreview = parentElement.appendChild(this.videoPreview);\n    }\n    this.videoPreview.src = this.videoPreviewSrc;\n    return this.videoPreview;\n  };\n  /**\n   * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets {@link state} to `READY` so the recording can start again\n   */\n  LocalRecorder.prototype.clean = function () {\n    var _this = this;\n    var f = function () {\n      delete _this.blob;\n      _this.chunks = [];\n      _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    };\n    if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n      this.stop().then(function () {\n        return f();\n      }).catch(function () {\n        return f();\n      });\n    } else {\n      f();\n    }\n  };\n  /**\n   * Downloads the recorded video through the browser. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.download = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"'LocalRecord.download()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + this.state + \"'). Call 'LocalRecorder.stop()' before\");\n    } else {\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      var url = globalThis.URL.createObjectURL(this.blob);\n      a.href = url;\n      a.download = this.id + '.' + Mime.getExtension(this.blob.type);\n      a.click();\n      globalThis.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    }\n  };\n  /**\n   * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.getBlob = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"Call 'LocalRecord.stop()' before getting Blob file\");\n    } else {\n      return this.blob;\n    }\n  };\n  /**\n   * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n   */\n  LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error(\"'LocalRecord.uploadAsBinary()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.stop()' before\"));\n      } else {\n        var http_1 = new XMLHttpRequest();\n        http_1.open('POST', endpoint, true);\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_1.setRequestHeader(key, headers[key]);\n          }\n        }\n        http_1.onreadystatechange = function () {\n          if (http_1.readyState === 4) {\n            if (http_1.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_1.responseText);\n            } else {\n              return reject(http_1.status);\n            }\n          }\n        };\n        http_1.send(_this.blob);\n      }\n    });\n  };\n  /**\n   * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n   */\n  LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error(\"'LocalRecord.uploadAsMultipartfile()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.stop()' before\"));\n      } else {\n        var http_2 = new XMLHttpRequest();\n        http_2.open('POST', endpoint, true);\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_2.setRequestHeader(key, headers[key]);\n          }\n        }\n        var sendable = new FormData();\n        sendable.append('file', _this.blob, _this.id + '.' + Mime.getExtension(_this.blob.type));\n        http_2.onreadystatechange = function () {\n          if (http_2.readyState === 4) {\n            if (http_2.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_2.responseText);\n            } else {\n              return reject(http_2.status);\n            }\n          }\n        };\n        http_2.send(sendable);\n      }\n    });\n  };\n  /* Private methods */\n  LocalRecorder.prototype.onStopDefault = function () {\n    logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n    this.blob = new Blob(this.chunks, {\n      type: this.mediaRecorder.mimeType\n    });\n    this.chunks = [];\n    this.videoPreviewSrc = globalThis.URL.createObjectURL(this.blob);\n    this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n  };\n  return LocalRecorder;\n}();\nexports.LocalRecorder = LocalRecorder;","map":{"version":3,"names":["LocalRecorderState_1","require","OpenViduLogger_1","Platform_1","Mime","logger","OpenViduLogger","getInstance","platform","LocalRecorder","stream","chunks","PlatformUtils","connectionId","connection","id","streamId","state","LocalRecorderState","READY","prototype","record","options","_this","Promise","resolve","reject","String","concat","MediaRecorder","error","Error","log","mimeType","mediaRecorder","getMediaStream","start","err","ondataavailable","e","data","size","push","onerror","onstart","onstop","onStopDefault","onpause","onresume","RECORDING","stop","FINISHED","pause","PAUSED","resume","preview","parentElement","videoPreview","document","createElement","autoplay","isSafariBrowser","playsInline","parentElementDom","getElementById","appendChild","src","videoPreviewSrc","clean","f","blob","then","catch","download","a","style","display","body","url","globalThis","URL","createObjectURL","href","getExtension","type","click","revokeObjectURL","removeChild","getBlob","uploadAsBinary","endpoint","headers","http_1","XMLHttpRequest","open","_i","_a","Object","keys","length","key","setRequestHeader","onreadystatechange","readyState","status","toString","charAt","responseText","send","uploadAsMultipartfile","http_2","sendable","FormData","append","Blob","exports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenVidu\\LocalRecorder.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Stream } from './Stream';\nimport { LocalRecorderState } from '../OpenViduInternal/Enums/LocalRecorderState';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport Mime = require('mime/lite');\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Easy recording of {@link Stream} objects straightaway from the browser. Initialized with {@link OpenVidu.initLocalRecorder} method\n */\nexport class LocalRecorder {\n    state: LocalRecorderState;\n\n    private connectionId: string;\n    private mediaRecorder: MediaRecorder;\n    private chunks: any[] = [];\n    private blob?: Blob;\n    private id: string;\n    private videoPreviewSrc: string;\n    private videoPreview: HTMLVideoElement;\n\n    /**\n     * @hidden\n     */\n    constructor(private stream: Stream) {\n        platform = PlatformUtils.getInstance();\n        this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n        this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n        this.state = LocalRecorderState.READY;\n    }\n\n    /**\n     * Starts the recording of the Stream. {@link state} property must be `READY`. After method succeeds is set to `RECORDING`\n     *\n     * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n     * For example:\n     *\n     * ```javascript\n     * var OV = new OpenVidu();\n     * var publisher = await OV.initPublisherAsync();\n     * var localRecorder = OV.initLocalRecorder(publisher.stream);\n     * var options = {\n     *      mimeType: 'video/webm;codecs=vp8',\n     *      audioBitsPerSecond:128000,\n     *      videoBitsPerSecond:2500000\n     * };\n     * localRecorder.record(options);\n     * ```\n     *\n     * If not specified, the default options preferred by the platform will be used.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n     */\n    record(options?: any): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (typeof options === 'string' || options instanceof String) {\n                    return reject(\n                        `When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \"${options}\" }`\n                    );\n                }\n                if (typeof MediaRecorder === 'undefined') {\n                    logger.error(\n                        'MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder'\n                    );\n                    throw Error(\n                        'MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder'\n                    );\n                }\n                if (this.state !== LocalRecorderState.READY) {\n                    throw Error(\n                        \"'LocalRecord.record()' needs 'LocalRecord.state' to be 'READY' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.clean()' or init a new LocalRecorder before\"\n                    );\n                }\n                logger.log(\"Starting local recording of stream '\" + this.stream.streamId + \"' of connection '\" + this.connectionId + \"'\");\n\n                if (!options) {\n                    options = { mimeType: 'video/webm' };\n                } else if (!options.mimeType) {\n                    options.mimeType = 'video/webm';\n                }\n\n                this.mediaRecorder = new MediaRecorder(this.stream.getMediaStream(), options);\n                this.mediaRecorder.start();\n            } catch (err) {\n                return reject(err);\n            }\n\n            this.mediaRecorder.ondataavailable = (e) => {\n                if (e.data.size > 0) {\n                    this.chunks.push(e.data);\n                }\n            };\n\n            this.mediaRecorder.onerror = (e) => {\n                logger.error('MediaRecorder error: ', e);\n            };\n\n            this.mediaRecorder.onstart = () => {\n                logger.log('MediaRecorder started (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onstop = () => {\n                this.onStopDefault();\n            };\n\n            this.mediaRecorder.onpause = () => {\n                logger.log('MediaRecorder paused (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onresume = () => {\n                logger.log('MediaRecorder resumed (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.state = LocalRecorderState.RECORDING;\n            return resolve();\n        });\n    }\n\n    /**\n     * Ends the recording of the Stream. {@link state} property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n     */\n    stop(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state === LocalRecorderState.READY || this.state === LocalRecorderState.FINISHED) {\n                    throw Error(\n                        \"'LocalRecord.stop()' needs 'LocalRecord.state' to be 'RECORDING' or 'PAUSED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.start()' before\"\n                    );\n                }\n                this.mediaRecorder.onstop = () => {\n                    this.onStopDefault();\n                    return resolve();\n                };\n                this.mediaRecorder.stop();\n            } catch (e) {\n                return reject(e);\n            }\n        });\n    }\n\n    /**\n     * Pauses the recording of the Stream. {@link state} property must be `RECORDING`. After method succeeds is set to `PAUSED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n     */\n    pause(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.RECORDING) {\n                    return reject(\n                        Error(\n                            \"'LocalRecord.pause()' needs 'LocalRecord.state' to be 'RECORDING' (current value: '\" +\n                                this.state +\n                                \"'). Call 'LocalRecorder.start()' or 'LocalRecorder.resume()' before\"\n                        )\n                    );\n                }\n                this.mediaRecorder.pause();\n                this.state = LocalRecorderState.PAUSED;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n    /**\n     * Resumes the recording of the Stream. {@link state} property must be `PAUSED`. After method succeeds is set to `RECORDING`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n     */\n    resume(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.PAUSED) {\n                    throw Error(\n                        \"'LocalRecord.resume()' needs 'LocalRecord.state' to be 'PAUSED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.pause()' before\"\n                    );\n                }\n                this.mediaRecorder.resume();\n                this.state = LocalRecorderState.RECORDING;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n    /**\n     * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. {@link state} property must be `FINISHED`\n     */\n    preview(parentElement): HTMLVideoElement {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\n                \"'LocalRecord.preview()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                    this.state +\n                    \"'). Call 'LocalRecorder.stop()' before\"\n            );\n        }\n\n        this.videoPreview = document.createElement('video');\n\n        this.videoPreview.id = this.id;\n        this.videoPreview.autoplay = true;\n\n        if (platform.isSafariBrowser()) {\n            this.videoPreview.playsInline = true;\n        }\n\n        if (typeof parentElement === 'string') {\n            const parentElementDom = document.getElementById(parentElement);\n            if (parentElementDom) {\n                this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n            }\n        } else {\n            this.videoPreview = parentElement.appendChild(this.videoPreview);\n        }\n\n        this.videoPreview.src = this.videoPreviewSrc;\n\n        return this.videoPreview;\n    }\n\n    /**\n     * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets {@link state} to `READY` so the recording can start again\n     */\n    clean(): void {\n        const f = () => {\n            delete this.blob;\n            this.chunks = [];\n            this.state = LocalRecorderState.READY;\n        };\n        if (this.state === LocalRecorderState.RECORDING || this.state === LocalRecorderState.PAUSED) {\n            this.stop()\n                .then(() => f())\n                .catch(() => f());\n        } else {\n            f();\n        }\n    }\n\n    /**\n     * Downloads the recorded video through the browser. {@link state} property must be `FINISHED`\n     */\n    download(): void {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\n                \"'LocalRecord.download()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                    this.state +\n                    \"'). Call 'LocalRecorder.stop()' before\"\n            );\n        } else {\n            const a: HTMLAnchorElement = document.createElement('a');\n            a.style.display = 'none';\n            document.body.appendChild(a);\n\n            const url = globalThis.URL.createObjectURL(<any>this.blob);\n            a.href = url;\n            a.download = this.id + '.' + Mime.getExtension(this.blob!.type);\n            a.click();\n            globalThis.URL.revokeObjectURL(url);\n\n            document.body.removeChild(a);\n        }\n    }\n\n    /**\n     * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. {@link state} property must be `FINISHED`\n     */\n    getBlob(): Blob {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\"Call 'LocalRecord.stop()' before getting Blob file\");\n        } else {\n            return this.blob!;\n        }\n    }\n\n    /**\n     * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n     */\n    uploadAsBinary(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(\n                    Error(\n                        \"'LocalRecord.uploadAsBinary()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.stop()' before\"\n                    )\n                );\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n                http.send(this.blob);\n            }\n        });\n    }\n\n    /**\n     * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n     */\n    uploadAsMultipartfile(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(\n                    Error(\n                        \"'LocalRecord.uploadAsMultipartfile()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.stop()' before\"\n                    )\n                );\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                const sendable = new FormData();\n                sendable.append('file', this.blob!, this.id + '.' + Mime.getExtension(this.blob!.type));\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n\n                http.send(sendable);\n            }\n        });\n    }\n\n    /* Private methods */\n\n    private onStopDefault(): void {\n        logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n\n        this.blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });\n        this.chunks = [];\n\n        this.videoPreviewSrc = globalThis.URL.createObjectURL(this.blob);\n\n        this.state = LocalRecorderState.FINISHED;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}