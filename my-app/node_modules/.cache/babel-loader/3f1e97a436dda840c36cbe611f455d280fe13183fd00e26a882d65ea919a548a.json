{"ast":null,"code":"var defineProperty_IE8 = false;\nif (Object.defineProperty) {\n  try {\n    Object.defineProperty({}, 'x', {});\n  } catch (e) {\n    defineProperty_IE8 = true;\n  }\n}\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n      fToBind = this,\n      fNOP = function () {},\n      fBound = function () {\n        return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n}\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('inherits');\nvar packers = require('./packers');\nvar Mapper = require('./Mapper');\nvar BASE_TIMEOUT = 5000;\nfunction unifyResponseMethods(responseMethods) {\n  if (!responseMethods) return {};\n  for (var key in responseMethods) {\n    var value = responseMethods[key];\n    if (typeof value == 'string') responseMethods[key] = {\n      response: value\n    };\n  }\n  return responseMethods;\n}\nfunction unifyTransport(transport) {\n  if (!transport) return;\n  if (transport instanceof Function) return {\n    send: transport\n  };\n  if (transport.send instanceof Function) return transport;\n  if (transport.postMessage instanceof Function) {\n    transport.send = transport.postMessage;\n    return transport;\n  }\n  if (transport.write instanceof Function) {\n    transport.send = transport.write;\n    return transport;\n  }\n  if (transport.onmessage !== undefined) return;\n  if (transport.pause instanceof Function) return;\n  throw new SyntaxError('Transport is not a function nor a valid object');\n}\nfunction RpcNotification(method, params) {\n  if (defineProperty_IE8) {\n    this.method = method;\n    this.params = params;\n  } else {\n    Object.defineProperty(this, 'method', {\n      value: method,\n      enumerable: true\n    });\n    Object.defineProperty(this, 'params', {\n      value: params,\n      enumerable: true\n    });\n  }\n}\nfunction RpcBuilder(packer, options, transport, onRequest) {\n  var self = this;\n  if (!packer) throw new SyntaxError('Packer is not defined');\n  if (!packer.pack || !packer.unpack) throw new SyntaxError('Packer is invalid');\n  var responseMethods = unifyResponseMethods(packer.responseMethods);\n  if (options instanceof Function) {\n    if (transport != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = options;\n    transport = undefined;\n    options = undefined;\n  }\n  if (options && options.send instanceof Function) {\n    if (transport && !(transport instanceof Function)) throw new SyntaxError('Only a function can be after transport');\n    onRequest = transport;\n    transport = options;\n    options = undefined;\n  }\n  if (transport instanceof Function) {\n    if (onRequest != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n    onRequest = transport;\n    transport = undefined;\n  }\n  if (transport && transport.send instanceof Function) if (onRequest && !(onRequest instanceof Function)) throw new SyntaxError('Only a function can be after transport');\n  options = options || {};\n  EventEmitter.call(this);\n  if (onRequest) this.on('request', onRequest);\n  if (defineProperty_IE8) this.peerID = options.peerID;else Object.defineProperty(this, 'peerID', {\n    value: options.peerID\n  });\n  var max_retries = options.max_retries || 0;\n  function transportMessage(event) {\n    self.decode(event.data || event);\n  }\n  this.getTransport = function () {\n    return transport;\n  };\n  this.setTransport = function (value) {\n    if (transport) {\n      if (transport.removeEventListener) transport.removeEventListener('message', transportMessage);else if (transport.removeListener) transport.removeListener('data', transportMessage);\n    }\n    if (value) {\n      if (value.addEventListener) value.addEventListener('message', transportMessage);else if (value.addListener) value.addListener('data', transportMessage);\n    }\n    transport = unifyTransport(value);\n  };\n  if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n    get: this.getTransport.bind(this),\n    set: this.setTransport.bind(this)\n  });\n  this.setTransport(transport);\n  var request_timeout = options.request_timeout || BASE_TIMEOUT;\n  var ping_request_timeout = options.ping_request_timeout || request_timeout;\n  var response_timeout = options.response_timeout || BASE_TIMEOUT;\n  var duplicates_timeout = options.duplicates_timeout || BASE_TIMEOUT;\n  var requestID = 0;\n  var requests = new Mapper();\n  var responses = new Mapper();\n  var processedResponses = new Mapper();\n  var message2Key = {};\n  function storeResponse(message, id, dest) {\n    var response = {\n      message: message,\n      timeout: setTimeout(function () {\n        responses.remove(id, dest);\n      }, response_timeout)\n    };\n    responses.set(response, id, dest);\n  }\n  function storeProcessedResponse(ack, from) {\n    var timeout = setTimeout(function () {\n      processedResponses.remove(ack, from);\n    }, duplicates_timeout);\n    processedResponses.set(timeout, ack, from);\n  }\n  function RpcRequest(method, params, id, from, transport) {\n    RpcNotification.call(this, method, params);\n    this.getTransport = function () {\n      return transport;\n    };\n    this.setTransport = function (value) {\n      transport = unifyTransport(value);\n    };\n    if (!defineProperty_IE8) Object.defineProperty(this, 'transport', {\n      get: this.getTransport.bind(this),\n      set: this.setTransport.bind(this)\n    });\n    var response = responses.get(id, from);\n    if (!(transport || self.getTransport())) {\n      if (defineProperty_IE8) this.duplicated = Boolean(response);else Object.defineProperty(this, 'duplicated', {\n        value: Boolean(response)\n      });\n    }\n    var responseMethod = responseMethods[method];\n    this.pack = packer.pack.bind(packer, this, id);\n    this.reply = function (error, result, transport) {\n      if (error instanceof Function || error && error.send instanceof Function) {\n        if (result != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = error;\n        result = null;\n        error = undefined;\n      } else if (result instanceof Function || result && result.send instanceof Function) {\n        if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n        transport = result;\n        result = null;\n      }\n      transport = unifyTransport(transport);\n      if (response) clearTimeout(response.timeout);\n      if (from != undefined) {\n        if (error) error.dest = from;\n        if (result) result.dest = from;\n      }\n      var message;\n      if (error || result != undefined) {\n        if (self.peerID != undefined) {\n          if (error) error.from = self.peerID;else result.from = self.peerID;\n        }\n        if (responseMethod) {\n          if (responseMethod.error == undefined && error) message = {\n            error: error\n          };else {\n            var method = error ? responseMethod.error : responseMethod.response;\n            message = {\n              method: method,\n              params: error || result\n            };\n          }\n        } else message = {\n          error: error,\n          result: result\n        };\n        message = packer.pack(message, id);\n      } else if (response) message = response.message;else message = packer.pack({\n        result: null\n      }, id);\n      storeResponse(message, id, from);\n      transport = transport || this.getTransport() || self.getTransport();\n      if (transport) return transport.send(message);\n      return message;\n    };\n  }\n  inherits(RpcRequest, RpcNotification);\n  function cancel(message) {\n    var key = message2Key[message];\n    if (!key) return;\n    delete message2Key[message];\n    var request = requests.pop(key.id, key.dest);\n    if (!request) return;\n    clearTimeout(request.timeout);\n    storeProcessedResponse(key.id, key.dest);\n  }\n  this.cancel = function (message) {\n    if (message) return cancel(message);\n    for (var message in message2Key) cancel(message);\n  };\n  this.close = function () {\n    var transport = this.getTransport();\n    if (transport && transport.close) transport.close(4003, 'Cancel request');\n    this.cancel();\n    processedResponses.forEach(clearTimeout);\n    responses.forEach(function (response) {\n      clearTimeout(response.timeout);\n    });\n  };\n  this.encode = function (method, params, dest, transport, callback) {\n    if (params instanceof Function) {\n      if (dest != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = params;\n      transport = undefined;\n      dest = undefined;\n      params = undefined;\n    } else if (dest instanceof Function) {\n      if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = dest;\n      transport = undefined;\n      dest = undefined;\n    } else if (transport instanceof Function) {\n      if (callback != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n      callback = transport;\n      transport = undefined;\n    }\n    if (self.peerID != undefined) {\n      params = params || {};\n      params.from = self.peerID;\n    }\n    if (dest != undefined) {\n      params = params || {};\n      params.dest = dest;\n    }\n    var message = {\n      method: method,\n      params: params\n    };\n    if (callback) {\n      var id = requestID++;\n      var retried = 0;\n      message = packer.pack(message, id);\n      function dispatchCallback(error, result) {\n        self.cancel(message);\n        callback(error, result);\n      }\n      var request = {\n        message: message,\n        callback: dispatchCallback,\n        responseMethods: responseMethods[method] || {}\n      };\n      var encode_transport = unifyTransport(transport);\n      function sendRequest(transport) {\n        var rt = method === 'ping' ? ping_request_timeout : request_timeout;\n        request.timeout = setTimeout(timeout, rt * Math.pow(2, retried++));\n        message2Key[message] = {\n          id: id,\n          dest: dest\n        };\n        requests.set(request, id, dest);\n        transport = transport || encode_transport || self.getTransport();\n        if (transport) return transport.send(message);\n        return message;\n      }\n      function retry(transport) {\n        transport = unifyTransport(transport);\n        console.warn(retried + ' retry for request message:', message);\n        var timeout = processedResponses.pop(id, dest);\n        clearTimeout(timeout);\n        return sendRequest(transport);\n      }\n      function timeout() {\n        if (retried < max_retries) return retry(transport);\n        var error = new Error('Request has timed out');\n        error.request = message;\n        error.retry = retry;\n        dispatchCallback(error);\n      }\n      return sendRequest(transport);\n    }\n    message = packer.pack(message);\n    transport = transport || this.getTransport();\n    if (transport) return transport.send(message);\n    return message;\n  };\n  this.decode = function (message, transport) {\n    if (!message) throw new TypeError('Message is not defined');\n    try {\n      message = packer.unpack(message);\n    } catch (e) {\n      return console.debug(e, message);\n    }\n    var id = message.id;\n    var ack = message.ack;\n    var method = message.method;\n    var params = message.params || {};\n    var from = params.from;\n    var dest = params.dest;\n    if (self.peerID != undefined && from == self.peerID) return;\n    if (id == undefined && ack == undefined) {\n      var notification = new RpcNotification(method, params);\n      if (self.emit('request', notification)) return;\n      return notification;\n    }\n    function processRequest() {\n      transport = unifyTransport(transport) || self.getTransport();\n      if (transport) {\n        var response = responses.get(id, from);\n        if (response) return transport.send(response.message);\n      }\n      var idAck = id != undefined ? id : ack;\n      var request = new RpcRequest(method, params, idAck, from, transport);\n      if (self.emit('request', request)) return;\n      return request;\n    }\n    function processResponse(request, error, result) {\n      request.callback(error, result);\n    }\n    function duplicatedResponse(timeout) {\n      console.warn('Response already processed', message);\n      clearTimeout(timeout);\n      storeProcessedResponse(ack, from);\n    }\n    if (method) {\n      if (dest == undefined || dest == self.peerID) {\n        var request = requests.get(ack, from);\n        if (request) {\n          var responseMethods = request.responseMethods;\n          if (method == responseMethods.error) return processResponse(request, params);\n          if (method == responseMethods.response) return processResponse(request, null, params);\n          return processRequest();\n        }\n        var processed = processedResponses.get(ack, from);\n        if (processed) return duplicatedResponse(processed);\n      }\n      return processRequest();\n    }\n    var error = message.error;\n    var result = message.result;\n    if (error && error.dest && error.dest != self.peerID) return;\n    if (result && result.dest && result.dest != self.peerID) return;\n    var request = requests.get(ack, from);\n    if (!request) {\n      var processed = processedResponses.get(ack, from);\n      if (processed) return duplicatedResponse(processed);\n      return console.warn('No callback was defined for this message', message);\n    }\n    processResponse(request, error, result);\n  };\n}\ninherits(RpcBuilder, EventEmitter);\nRpcBuilder.RpcNotification = RpcNotification;\nmodule.exports = RpcBuilder;\nvar clients = require('./clients');\nvar transports = require('./clients/transports');\nRpcBuilder.clients = clients;\nRpcBuilder.clients.transports = transports;\nRpcBuilder.packers = packers;","map":{"version":3,"names":["defineProperty_IE8","Object","defineProperty","e","Function","prototype","bind","oThis","TypeError","aArgs","Array","slice","call","arguments","fToBind","fNOP","fBound","apply","concat","EventEmitter","require","inherits","packers","Mapper","BASE_TIMEOUT","unifyResponseMethods","responseMethods","key","value","response","unifyTransport","transport","send","postMessage","write","onmessage","undefined","pause","SyntaxError","RpcNotification","method","params","enumerable","RpcBuilder","packer","options","onRequest","self","pack","unpack","on","peerID","max_retries","transportMessage","event","decode","data","getTransport","setTransport","removeEventListener","removeListener","addEventListener","addListener","get","set","request_timeout","ping_request_timeout","response_timeout","duplicates_timeout","requestID","requests","responses","processedResponses","message2Key","storeResponse","message","id","dest","timeout","setTimeout","remove","storeProcessedResponse","ack","from","RpcRequest","duplicated","Boolean","responseMethod","reply","error","result","clearTimeout","cancel","request","pop","close","forEach","encode","callback","retried","dispatchCallback","encode_transport","sendRequest","rt","Math","pow","retry","console","warn","Error","debug","notification","emit","processRequest","idAck","processResponse","duplicatedResponse","processed","module","exports","clients","transports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\index.js"],"sourcesContent":["/*\n * (C) Copyright 2014 Kurento (http://kurento.org/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar defineProperty_IE8 = false;\nif (Object.defineProperty) {\n    try {\n        Object.defineProperty({}, 'x', {});\n    } catch (e) {\n        defineProperty_IE8 = true;\n    }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n        if (typeof this !== 'function') {\n            // closest thing possible to the ECMAScript 5\n            // internal IsCallable function\n            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n        }\n\n        var aArgs = Array.prototype.slice.call(arguments, 1),\n            fToBind = this,\n            fNOP = function () {},\n            fBound = function () {\n                return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n            };\n\n        fNOP.prototype = this.prototype;\n        fBound.prototype = new fNOP();\n\n        return fBound;\n    };\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('inherits');\n\nvar packers = require('./packers');\nvar Mapper = require('./Mapper');\n\nvar BASE_TIMEOUT = 5000;\n\nfunction unifyResponseMethods(responseMethods) {\n    if (!responseMethods) return {};\n\n    for (var key in responseMethods) {\n        var value = responseMethods[key];\n\n        if (typeof value == 'string')\n            responseMethods[key] = {\n                response: value\n            };\n    }\n\n    return responseMethods;\n}\n\nfunction unifyTransport(transport) {\n    if (!transport) return;\n\n    // Transport as a function\n    if (transport instanceof Function)\n        return {\n            send: transport\n        };\n\n    // WebSocket & DataChannel\n    if (transport.send instanceof Function) return transport;\n\n    // Message API (Inter-window & WebWorker)\n    if (transport.postMessage instanceof Function) {\n        transport.send = transport.postMessage;\n        return transport;\n    }\n\n    // Stream API\n    if (transport.write instanceof Function) {\n        transport.send = transport.write;\n        return transport;\n    }\n\n    // Transports that only can receive messages, but not send\n    if (transport.onmessage !== undefined) return;\n    if (transport.pause instanceof Function) return;\n\n    throw new SyntaxError('Transport is not a function nor a valid object');\n}\n\n/**\n * Representation of a RPC notification\n *\n * @class\n *\n * @constructor\n *\n * @param {String} method -method of the notification\n * @param params - parameters of the notification\n */\nfunction RpcNotification(method, params) {\n    if (defineProperty_IE8) {\n        this.method = method;\n        this.params = params;\n    } else {\n        Object.defineProperty(this, 'method', {\n            value: method,\n            enumerable: true\n        });\n        Object.defineProperty(this, 'params', {\n            value: params,\n            enumerable: true\n        });\n    }\n}\n\n/**\n * @class\n *\n * @constructor\n *\n * @param {object} packer\n *\n * @param {object} [options]\n *\n * @param {object} [transport]\n *\n * @param {Function} [onRequest]\n */\nfunction RpcBuilder(packer, options, transport, onRequest) {\n    var self = this;\n\n    if (!packer) throw new SyntaxError('Packer is not defined');\n\n    if (!packer.pack || !packer.unpack) throw new SyntaxError('Packer is invalid');\n\n    var responseMethods = unifyResponseMethods(packer.responseMethods);\n\n    if (options instanceof Function) {\n        if (transport != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n\n        onRequest = options;\n        transport = undefined;\n        options = undefined;\n    }\n\n    if (options && options.send instanceof Function) {\n        if (transport && !(transport instanceof Function)) throw new SyntaxError('Only a function can be after transport');\n\n        onRequest = transport;\n        transport = options;\n        options = undefined;\n    }\n\n    if (transport instanceof Function) {\n        if (onRequest != undefined) throw new SyntaxError(\"There can't be parameters after onRequest\");\n\n        onRequest = transport;\n        transport = undefined;\n    }\n\n    if (transport && transport.send instanceof Function)\n        if (onRequest && !(onRequest instanceof Function)) throw new SyntaxError('Only a function can be after transport');\n\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    if (onRequest) this.on('request', onRequest);\n\n    if (defineProperty_IE8) this.peerID = options.peerID;\n    else\n        Object.defineProperty(this, 'peerID', {\n            value: options.peerID\n        });\n\n    var max_retries = options.max_retries || 0;\n\n    function transportMessage(event) {\n        self.decode(event.data || event);\n    }\n\n    this.getTransport = function () {\n        return transport;\n    };\n    this.setTransport = function (value) {\n        // Remove listener from old transport\n        if (transport) {\n            // W3C transports\n            if (transport.removeEventListener) transport.removeEventListener('message', transportMessage);\n            // Node.js Streams API\n            else if (transport.removeListener) transport.removeListener('data', transportMessage);\n        }\n\n        // Set listener on new transport\n        if (value) {\n            // W3C transports\n            if (value.addEventListener) value.addEventListener('message', transportMessage);\n            // Node.js Streams API\n            else if (value.addListener) value.addListener('data', transportMessage);\n        }\n\n        transport = unifyTransport(value);\n    };\n\n    if (!defineProperty_IE8)\n        Object.defineProperty(this, 'transport', {\n            get: this.getTransport.bind(this),\n            set: this.setTransport.bind(this)\n        });\n\n    this.setTransport(transport);\n\n    var request_timeout = options.request_timeout || BASE_TIMEOUT;\n    var ping_request_timeout = options.ping_request_timeout || request_timeout;\n    var response_timeout = options.response_timeout || BASE_TIMEOUT;\n    var duplicates_timeout = options.duplicates_timeout || BASE_TIMEOUT;\n\n    var requestID = 0;\n\n    var requests = new Mapper();\n    var responses = new Mapper();\n    var processedResponses = new Mapper();\n\n    var message2Key = {};\n\n    /**\n     * Store the response to prevent to process duplicate request later\n     */\n    function storeResponse(message, id, dest) {\n        var response = {\n            message: message,\n            /** Timeout to auto-clean old responses */\n            timeout: setTimeout(function () {\n                responses.remove(id, dest);\n            }, response_timeout)\n        };\n\n        responses.set(response, id, dest);\n    }\n\n    /**\n     * Store the response to ignore duplicated messages later\n     */\n    function storeProcessedResponse(ack, from) {\n        var timeout = setTimeout(function () {\n            processedResponses.remove(ack, from);\n        }, duplicates_timeout);\n\n        processedResponses.set(timeout, ack, from);\n    }\n\n    /**\n     * Representation of a RPC request\n     *\n     * @class\n     * @extends RpcNotification\n     *\n     * @constructor\n     *\n     * @param {String} method -method of the notification\n     * @param params - parameters of the notification\n     * @param {Integer} id - identifier of the request\n     * @param [from] - source of the notification\n     */\n    function RpcRequest(method, params, id, from, transport) {\n        RpcNotification.call(this, method, params);\n\n        this.getTransport = function () {\n            return transport;\n        };\n        this.setTransport = function (value) {\n            transport = unifyTransport(value);\n        };\n\n        if (!defineProperty_IE8)\n            Object.defineProperty(this, 'transport', {\n                get: this.getTransport.bind(this),\n                set: this.setTransport.bind(this)\n            });\n\n        var response = responses.get(id, from);\n\n        /**\n         * @constant {Boolean} duplicated\n         */\n        if (!(transport || self.getTransport())) {\n            if (defineProperty_IE8) this.duplicated = Boolean(response);\n            else\n                Object.defineProperty(this, 'duplicated', {\n                    value: Boolean(response)\n                });\n        }\n\n        var responseMethod = responseMethods[method];\n\n        this.pack = packer.pack.bind(packer, this, id);\n\n        /**\n         * Generate a response to this request\n         *\n         * @param {Error} [error]\n         * @param {*} [result]\n         *\n         * @returns {string}\n         */\n        this.reply = function (error, result, transport) {\n            // Fix optional parameters\n            if (error instanceof Function || (error && error.send instanceof Function)) {\n                if (result != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n\n                transport = error;\n                result = null;\n                error = undefined;\n            } else if (result instanceof Function || (result && result.send instanceof Function)) {\n                if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n\n                transport = result;\n                result = null;\n            }\n\n            transport = unifyTransport(transport);\n\n            // Duplicated request, remove old response timeout\n            if (response) clearTimeout(response.timeout);\n\n            if (from != undefined) {\n                if (error) error.dest = from;\n\n                if (result) result.dest = from;\n            }\n\n            var message;\n\n            // New request or overriden one, create new response with provided data\n            if (error || result != undefined) {\n                if (self.peerID != undefined) {\n                    if (error) error.from = self.peerID;\n                    else result.from = self.peerID;\n                }\n\n                // Protocol indicates that responses has own request methods\n                if (responseMethod) {\n                    if (responseMethod.error == undefined && error)\n                        message = {\n                            error: error\n                        };\n                    else {\n                        var method = error ? responseMethod.error : responseMethod.response;\n\n                        message = {\n                            method: method,\n                            params: error || result\n                        };\n                    }\n                } else\n                    message = {\n                        error: error,\n                        result: result\n                    };\n\n                message = packer.pack(message, id);\n            }\n\n            // Duplicate & not-overriden request, re-send old response\n            else if (response) message = response.message;\n            // New empty reply, response null value\n            else\n                message = packer.pack(\n                    {\n                        result: null\n                    },\n                    id\n                );\n\n            // Store the response to prevent to process a duplicated request later\n            storeResponse(message, id, from);\n\n            // Return the stored response so it can be directly send back\n            transport = transport || this.getTransport() || self.getTransport();\n\n            if (transport) return transport.send(message);\n\n            return message;\n        };\n    }\n    inherits(RpcRequest, RpcNotification);\n\n    function cancel(message) {\n        var key = message2Key[message];\n        if (!key) return;\n\n        delete message2Key[message];\n\n        var request = requests.pop(key.id, key.dest);\n        if (!request) return;\n\n        clearTimeout(request.timeout);\n\n        // Start duplicated responses timeout\n        storeProcessedResponse(key.id, key.dest);\n    }\n\n    /**\n     * Allow to cancel a request and don't wait for a response\n     *\n     * If `message` is not given, cancel all the request\n     */\n    this.cancel = function (message) {\n        if (message) return cancel(message);\n\n        for (var message in message2Key) cancel(message);\n    };\n\n    this.close = function () {\n        // Prevent to receive new messages\n        var transport = this.getTransport();\n        if (transport && transport.close) transport.close(4003, 'Cancel request');\n\n        // Request & processed responses\n        this.cancel();\n\n        processedResponses.forEach(clearTimeout);\n\n        // Responses\n        responses.forEach(function (response) {\n            clearTimeout(response.timeout);\n        });\n    };\n\n    /**\n     * Generates and encode a JsonRPC 2.0 message\n     *\n     * @param {String} method -method of the notification\n     * @param params - parameters of the notification\n     * @param [dest] - destination of the notification\n     * @param {object} [transport] - transport where to send the message\n     * @param [callback] - function called when a response to this request is\n     *   received. If not defined, a notification will be send instead\n     *\n     * @returns {string} A raw JsonRPC 2.0 request or notification string\n     */\n    this.encode = function (method, params, dest, transport, callback) {\n        // Fix optional parameters\n        if (params instanceof Function) {\n            if (dest != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n\n            callback = params;\n            transport = undefined;\n            dest = undefined;\n            params = undefined;\n        } else if (dest instanceof Function) {\n            if (transport != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n\n            callback = dest;\n            transport = undefined;\n            dest = undefined;\n        } else if (transport instanceof Function) {\n            if (callback != undefined) throw new SyntaxError(\"There can't be parameters after callback\");\n\n            callback = transport;\n            transport = undefined;\n        }\n\n        if (self.peerID != undefined) {\n            params = params || {};\n\n            params.from = self.peerID;\n        }\n\n        if (dest != undefined) {\n            params = params || {};\n\n            params.dest = dest;\n        }\n\n        // Encode message\n        var message = {\n            method: method,\n            params: params\n        };\n\n        if (callback) {\n            var id = requestID++;\n            var retried = 0;\n\n            message = packer.pack(message, id);\n\n            function dispatchCallback(error, result) {\n                self.cancel(message);\n\n                callback(error, result);\n            }\n\n            var request = {\n                message: message,\n                callback: dispatchCallback,\n                responseMethods: responseMethods[method] || {}\n            };\n\n            var encode_transport = unifyTransport(transport);\n\n            function sendRequest(transport) {\n                var rt = method === 'ping' ? ping_request_timeout : request_timeout;\n                request.timeout = setTimeout(timeout, rt * Math.pow(2, retried++));\n                message2Key[message] = {\n                    id: id,\n                    dest: dest\n                };\n                requests.set(request, id, dest);\n\n                transport = transport || encode_transport || self.getTransport();\n                if (transport) return transport.send(message);\n\n                return message;\n            }\n\n            function retry(transport) {\n                transport = unifyTransport(transport);\n\n                console.warn(retried + ' retry for request message:', message);\n\n                var timeout = processedResponses.pop(id, dest);\n                clearTimeout(timeout);\n\n                return sendRequest(transport);\n            }\n\n            function timeout() {\n                if (retried < max_retries) return retry(transport);\n\n                var error = new Error('Request has timed out');\n                error.request = message;\n\n                error.retry = retry;\n\n                dispatchCallback(error);\n            }\n\n            return sendRequest(transport);\n        }\n\n        // Return the packed message\n        message = packer.pack(message);\n\n        transport = transport || this.getTransport();\n        if (transport) return transport.send(message);\n\n        return message;\n    };\n\n    /**\n     * Decode and process a JsonRPC 2.0 message\n     *\n     * @param {string} message - string with the content of the message\n     *\n     * @returns {RpcNotification|RpcRequest|undefined} - the representation of the\n     *   notification or the request. If a response was processed, it will return\n     *   `undefined` to notify that it was processed\n     *\n     * @throws {TypeError} - Message is not defined\n     */\n    this.decode = function (message, transport) {\n        if (!message) throw new TypeError('Message is not defined');\n\n        try {\n            message = packer.unpack(message);\n        } catch (e) {\n            // Ignore invalid messages\n            return console.debug(e, message);\n        }\n\n        var id = message.id;\n        var ack = message.ack;\n        var method = message.method;\n        var params = message.params || {};\n\n        var from = params.from;\n        var dest = params.dest;\n\n        // Ignore messages send by us\n        if (self.peerID != undefined && from == self.peerID) return;\n\n        // Notification\n        if (id == undefined && ack == undefined) {\n            var notification = new RpcNotification(method, params);\n\n            if (self.emit('request', notification)) return;\n            return notification;\n        }\n\n        function processRequest() {\n            // If we have a transport and it's a duplicated request, reply inmediatly\n            transport = unifyTransport(transport) || self.getTransport();\n            if (transport) {\n                var response = responses.get(id, from);\n                if (response) return transport.send(response.message);\n            }\n\n            var idAck = id != undefined ? id : ack;\n            var request = new RpcRequest(method, params, idAck, from, transport);\n\n            if (self.emit('request', request)) return;\n            return request;\n        }\n\n        function processResponse(request, error, result) {\n            request.callback(error, result);\n        }\n\n        function duplicatedResponse(timeout) {\n            console.warn('Response already processed', message);\n\n            // Update duplicated responses timeout\n            clearTimeout(timeout);\n            storeProcessedResponse(ack, from);\n        }\n\n        // Request, or response with own method\n        if (method) {\n            // Check if it's a response with own method\n            if (dest == undefined || dest == self.peerID) {\n                var request = requests.get(ack, from);\n                if (request) {\n                    var responseMethods = request.responseMethods;\n\n                    if (method == responseMethods.error) return processResponse(request, params);\n\n                    if (method == responseMethods.response) return processResponse(request, null, params);\n\n                    return processRequest();\n                }\n\n                var processed = processedResponses.get(ack, from);\n                if (processed) return duplicatedResponse(processed);\n            }\n\n            // Request\n            return processRequest();\n        }\n\n        var error = message.error;\n        var result = message.result;\n\n        // Ignore responses not send to us\n        if (error && error.dest && error.dest != self.peerID) return;\n        if (result && result.dest && result.dest != self.peerID) return;\n\n        // Response\n        var request = requests.get(ack, from);\n        if (!request) {\n            var processed = processedResponses.get(ack, from);\n            if (processed) return duplicatedResponse(processed);\n\n            return console.warn('No callback was defined for this message', message);\n        }\n\n        // Process response\n        processResponse(request, error, result);\n    };\n}\ninherits(RpcBuilder, EventEmitter);\n\nRpcBuilder.RpcNotification = RpcNotification;\n\nmodule.exports = RpcBuilder;\n\nvar clients = require('./clients');\nvar transports = require('./clients/transports');\n\nRpcBuilder.clients = clients;\nRpcBuilder.clients.transports = transports;\nRpcBuilder.packers = packers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}