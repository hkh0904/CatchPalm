{"ast":null,"code":"function pack(message, id) {\n  var result = {\n    jsonrpc: '2.0'\n  };\n  if (message.method) {\n    result.method = message.method;\n    if (message.params) result.params = message.params;\n    if (id != undefined) result.id = id;\n  } else if (id != undefined) {\n    if (message.error) {\n      if (message.result !== undefined) throw new TypeError('Both result and error are defined');\n      result.error = message.error;\n    } else if (message.result !== undefined) result.result = message.result;else throw new TypeError('No result or error is defined');\n    result.id = id;\n  }\n  return JSON.stringify(result);\n}\nfunction unpack(message) {\n  var result = message;\n  if (typeof message === 'string' || message instanceof String) {\n    result = JSON.parse(message);\n  }\n  var version = result.jsonrpc;\n  if (version !== '2.0') throw new TypeError(\"Invalid JsonRPC version '\" + version + \"': \" + message);\n  if (result.method == undefined) {\n    if (result.id == undefined) throw new TypeError('Invalid message: ' + message);\n    var result_defined = result.result !== undefined;\n    var error_defined = result.error !== undefined;\n    if (result_defined && error_defined) throw new TypeError('Both result and error are defined: ' + message);\n    if (!result_defined && !error_defined) throw new TypeError('No result or error is defined: ' + message);\n    result.ack = result.id;\n    delete result.id;\n  }\n  return result;\n}\nexports.pack = pack;\nexports.unpack = unpack;","map":{"version":3,"names":["pack","message","id","result","jsonrpc","method","params","undefined","error","TypeError","JSON","stringify","unpack","String","parse","version","result_defined","error_defined","ack","exports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\packers\\JsonRPC.js"],"sourcesContent":["/**\n * JsonRPC 2.0 packer\n */\n\n/**\n * Pack a JsonRPC 2.0 message\n *\n * @param {Object} message - object to be packaged. It requires to have all the\n *   fields needed by the JsonRPC 2.0 message that it's going to be generated\n *\n * @return {String} - the stringified JsonRPC 2.0 message\n */\nfunction pack(message, id) {\n    var result = {\n        jsonrpc: '2.0'\n    };\n\n    // Request\n    if (message.method) {\n        result.method = message.method;\n\n        if (message.params) result.params = message.params;\n\n        // Request is a notification\n        if (id != undefined) result.id = id;\n    }\n\n    // Response\n    else if (id != undefined) {\n        if (message.error) {\n            if (message.result !== undefined) throw new TypeError('Both result and error are defined');\n\n            result.error = message.error;\n        } else if (message.result !== undefined) result.result = message.result;\n        else throw new TypeError('No result or error is defined');\n\n        result.id = id;\n    }\n\n    return JSON.stringify(result);\n}\n\n/**\n * Unpack a JsonRPC 2.0 message\n *\n * @param {String} message - string with the content of the JsonRPC 2.0 message\n *\n * @throws {TypeError} - Invalid JsonRPC version\n *\n * @return {Object} - object filled with the JsonRPC 2.0 message content\n */\nfunction unpack(message) {\n    var result = message;\n\n    if (typeof message === 'string' || message instanceof String) {\n        result = JSON.parse(message);\n    }\n\n    // Check if it's a valid message\n\n    var version = result.jsonrpc;\n    if (version !== '2.0') throw new TypeError(\"Invalid JsonRPC version '\" + version + \"': \" + message);\n\n    // Response\n    if (result.method == undefined) {\n        if (result.id == undefined) throw new TypeError('Invalid message: ' + message);\n\n        var result_defined = result.result !== undefined;\n        var error_defined = result.error !== undefined;\n\n        // Check only result or error is defined, not both or none\n        if (result_defined && error_defined) throw new TypeError('Both result and error are defined: ' + message);\n\n        if (!result_defined && !error_defined) throw new TypeError('No result or error is defined: ' + message);\n\n        result.ack = result.id;\n        delete result.id;\n    }\n\n    // Return unpacked message\n    return result;\n}\n\nexports.pack = pack;\nexports.unpack = unpack;\n"],"mappings":"AAYA,SAASA,IAAIA,CAACC,OAAO,EAAEC,EAAE;EACrB,IAAIC,MAAM,GAAG;IACTC,OAAO,EAAE;GACZ;EAGD,IAAIH,OAAO,CAACI,MAAM,EAAE;IAChBF,MAAM,CAACE,MAAM,GAAGJ,OAAO,CAACI,MAAM;IAE9B,IAAIJ,OAAO,CAACK,MAAM,EAAEH,MAAM,CAACG,MAAM,GAAGL,OAAO,CAACK,MAAM;IAGlD,IAAIJ,EAAE,IAAIK,SAAS,EAAEJ,MAAM,CAACD,EAAE,GAAGA,EAAE;GACtC,MAGI,IAAIA,EAAE,IAAIK,SAAS,EAAE;IACtB,IAAIN,OAAO,CAACO,KAAK,EAAE;MACf,IAAIP,OAAO,CAACE,MAAM,KAAKI,SAAS,EAAE,MAAM,IAAIE,SAAS,CAAC,mCAAmC,CAAC;MAE1FN,MAAM,CAACK,KAAK,GAAGP,OAAO,CAACO,KAAK;KAC/B,MAAM,IAAIP,OAAO,CAACE,MAAM,KAAKI,SAAS,EAAEJ,MAAM,CAACA,MAAM,GAAGF,OAAO,CAACE,MAAM,CAAC,KACnE,MAAM,IAAIM,SAAS,CAAC,+BAA+B,CAAC;IAEzDN,MAAM,CAACD,EAAE,GAAGA,EAAE;;EAGlB,OAAOQ,IAAI,CAACC,SAAS,CAACR,MAAM,CAAC;AACjC;AAWA,SAASS,MAAMA,CAACX,OAAO;EACnB,IAAIE,MAAM,GAAGF,OAAO;EAEpB,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,YAAYY,MAAM,EAAE;IAC1DV,MAAM,GAAGO,IAAI,CAACI,KAAK,CAACb,OAAO,CAAC;;EAKhC,IAAIc,OAAO,GAAGZ,MAAM,CAACC,OAAO;EAC5B,IAAIW,OAAO,KAAK,KAAK,EAAE,MAAM,IAAIN,SAAS,CAAC,2BAA2B,GAAGM,OAAO,GAAG,KAAK,GAAGd,OAAO,CAAC;EAGnG,IAAIE,MAAM,CAACE,MAAM,IAAIE,SAAS,EAAE;IAC5B,IAAIJ,MAAM,CAACD,EAAE,IAAIK,SAAS,EAAE,MAAM,IAAIE,SAAS,CAAC,mBAAmB,GAAGR,OAAO,CAAC;IAE9E,IAAIe,cAAc,GAAGb,MAAM,CAACA,MAAM,KAAKI,SAAS;IAChD,IAAIU,aAAa,GAAGd,MAAM,CAACK,KAAK,KAAKD,SAAS;IAG9C,IAAIS,cAAc,IAAIC,aAAa,EAAE,MAAM,IAAIR,SAAS,CAAC,qCAAqC,GAAGR,OAAO,CAAC;IAEzG,IAAI,CAACe,cAAc,IAAI,CAACC,aAAa,EAAE,MAAM,IAAIR,SAAS,CAAC,iCAAiC,GAAGR,OAAO,CAAC;IAEvGE,MAAM,CAACe,GAAG,GAAGf,MAAM,CAACD,EAAE;IACtB,OAAOC,MAAM,CAACD,EAAE;;EAIpB,OAAOC,MAAM;AACjB;AAEAgB,OAAO,CAACnB,IAAI,GAAGA,IAAI;AACnBmB,OAAO,CAACP,MAAM,GAAGA,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}