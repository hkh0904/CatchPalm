{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Publisher = void 0;\nvar Session_1 = require(\"./Session\");\nvar Stream_1 = require(\"./Stream\");\nvar StreamManager_1 = require(\"./StreamManager\");\nvar StreamEvent_1 = require(\"../OpenViduInternal/Events/StreamEvent\");\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with {@link OpenVidu.initPublisher} method.\n *\n * See available event listeners at {@link PublisherEventMap}.\n */\nvar Publisher = /** @class */function (_super) {\n  __extends(Publisher, _super);\n  /**\n   * @hidden\n   */\n  function Publisher(targEl, properties, openvidu) {\n    var _this = _super.call(this, new Stream_1.Stream(!!openvidu.session ? openvidu.session : new Session_1.Session(openvidu), {\n      publisherProperties: properties,\n      mediaConstraints: {}\n    }), targEl) || this;\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n    _this.accessAllowed = false;\n    /**\n     * Whether you have called {@link Publisher.subscribeToRemote} with value `true` or `false` (*false* by default)\n     */\n    _this.isSubscribedToRemote = false;\n    _this.accessDenied = false;\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.properties = properties;\n    _this.openvidu = openvidu;\n    _this.stream.ee.on('local-stream-destroyed', function (reason) {\n      _this.stream.isLocalStreamPublished = false;\n      var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', _this.stream, reason);\n      _this.emitEvent('streamDestroyed', [streamEvent]);\n      streamEvent.callDefaultBehavior();\n    });\n    return _this;\n  }\n  /**\n   * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The {@link Publisher} object of the local participant will also dispatch the exact same event\n   *\n   * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See {@link StreamPropertyChangedEvent} to learn more.\n   *\n   * @param enabled `true` to publish the audio stream, `false` to unpublish it\n   */\n  Publisher.prototype.publishAudio = function (enabled) {\n    var _this = this;\n    if (this.stream.audioActive !== enabled) {\n      var affectedMediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n      affectedMediaStream.getAudioTracks().forEach(function (track) {\n        track.enabled = enabled;\n      });\n      if (!!this.session && !!this.stream.streamId) {\n        this.session.openvidu.sendRequest('streamPropertyChanged', {\n          streamId: this.stream.streamId,\n          property: 'audioActive',\n          newValue: enabled,\n          reason: 'publishAudio'\n        }, function (error, response) {\n          if (error) {\n            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n          } else {\n            _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n            _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n            _this.session.sendVideoData(_this.stream.streamManager);\n          }\n        });\n      }\n      this.stream.audioActive = enabled;\n      logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n    }\n  };\n  /**\n   * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The {@link Publisher} object of the local participant will also dispatch the exact same event\n   *\n   * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See {@link StreamPropertyChangedEvent} to learn more.\n   *\n   * @param enabled `true` to publish the video stream, `false` to unpublish it\n   * @param resource\n   *\n   * If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n   * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n   * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.\n   *\n   * If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n   * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n   * will be used instead.\n   */\n  Publisher.prototype.publishVideo = function (enabled, resource) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var affectedMediaStream_1, mustRestartMediaStream_1, oldVideoTrack, replaceVideoTrack, mediaStream, error_1;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.stream.videoActive !== enabled)) return [3 /*break*/, 9];\n              affectedMediaStream_1 = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n              mustRestartMediaStream_1 = false;\n              affectedMediaStream_1.getVideoTracks().forEach(function (track) {\n                track.enabled = enabled;\n                if (!enabled && resource === true) {\n                  track.stop();\n                } else if (enabled && track.readyState === 'ended') {\n                  // Resource was freed\n                  mustRestartMediaStream_1 = true;\n                }\n              });\n              if (!(!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:'))) return [3 /*break*/, 2];\n              this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n              return [4 /*yield*/, this.stream.removeFilterAux(true)];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              if (!mustRestartMediaStream_1) return [3 /*break*/, 8];\n              oldVideoTrack = affectedMediaStream_1.getVideoTracks()[0];\n              affectedMediaStream_1.removeTrack(oldVideoTrack);\n              replaceVideoTrack = function (tr) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _this = this;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        affectedMediaStream_1.addTrack(tr);\n                        if (!this.stream.isLocalStreamPublished) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.replaceTrackInRtcRtpSender(tr)];\n                      case 1:\n                        _a.sent();\n                        _a.label = 2;\n                      case 2:\n                        if (!!this.stream.lastVBFilter) {\n                          setTimeout(function () {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var options, lastExecMethod;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    options = this.stream.lastVBFilter.options;\n                                    lastExecMethod = this.stream.lastVBFilter.lastExecMethod;\n                                    if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                      options = Object.assign({}, options, lastExecMethod.params);\n                                    }\n                                    return [4 /*yield*/, this.stream.applyFilter(this.stream.lastVBFilter.type, options)];\n                                  case 1:\n                                    _a.sent();\n                                    delete this.stream.lastVBFilter;\n                                    return [2 /*return*/];\n                                }\n                              });\n                            });\n                          }, 1);\n                        }\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              if (!(!!resource && resource instanceof MediaStreamTrack)) return [3 /*break*/, 4];\n              return [4 /*yield*/, replaceVideoTrack(resource)];\n            case 3:\n              _a.sent();\n              return [3 /*break*/, 8];\n            case 4:\n              _a.trys.push([4, 7,, 8]);\n              return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: this.stream.lastVideoTrackConstraints\n              })];\n            case 5:\n              mediaStream = _a.sent();\n              return [4 /*yield*/, replaceVideoTrack(mediaStream.getVideoTracks()[0])];\n            case 6:\n              _a.sent();\n              return [3 /*break*/, 8];\n            case 7:\n              error_1 = _a.sent();\n              return [2 /*return*/, reject(error_1)];\n            case 8:\n              if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest('streamPropertyChanged', {\n                  streamId: this.stream.streamId,\n                  property: 'videoActive',\n                  newValue: enabled,\n                  reason: 'publishVideo'\n                }, function (error, response) {\n                  if (error) {\n                    logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                  } else {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                    _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                    _this.session.sendVideoData(_this.stream.streamManager);\n                  }\n                });\n              }\n              this.stream.videoActive = enabled;\n              logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n              return [2 /*return*/, resolve()];\n            case 9:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Call this method before {@link Session.publish} if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n   */\n  Publisher.prototype.subscribeToRemote = function (value) {\n    value = value !== undefined ? value : true;\n    this.isSubscribedToRemote = value;\n    this.stream.subscribeToMyRemote(value);\n  };\n  /**\n   * See {@link EventDispatcher.on}\n   */\n  Publisher.prototype.on = function (type, handler) {\n    var _this = this;\n    _super.prototype.on.call(this, type, handler);\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.on('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n    return this;\n  };\n  /**\n   * See {@link EventDispatcher.once}\n   */\n  Publisher.prototype.once = function (type, handler) {\n    var _this = this;\n    _super.prototype.once.call(this, type, handler);\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.once('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n    return this;\n  };\n  /**\n   * See {@link EventDispatcher.off}\n   */\n  Publisher.prototype.off = function (type, handler) {\n    _super.prototype.off.call(this, type, handler);\n    return this;\n  };\n  /**\n   * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n   * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n   * and publishing the new one).\n   *\n   * You can get this new MediaStreamTrack by using the native Web API or simply with {@link OpenVidu.getUserMedia} method.\n   *\n   * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n   * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n   * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n   *\n   * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n   * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n   */\n  Publisher.prototype.replaceTrack = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.replaceTrackAux(track, true)];\n      });\n    });\n  };\n  /* Hidden methods */\n  /**\n   * @hidden\n   */\n  Publisher.prototype.initialize = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var constraints, constraintsAux, timeForDialogEvent, startTime, errorCallback, successCallback, getMediaSuccess, getMediaError, myConstraints, outboundStreamOptions, definedAudioConstraint, mediaStream, mediaStream, error_2, error_3;\n        var _this = this;\n        var _a, _b;\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              constraints = {};\n              constraintsAux = {};\n              timeForDialogEvent = 2000;\n              errorCallback = function (openViduError) {\n                _this.accessDenied = true;\n                _this.accessAllowed = false;\n                logger.error(\"Publisher initialization failed. \".concat(openViduError.name, \": \").concat(openViduError.message));\n                return reject(openViduError);\n              };\n              successCallback = function (mediaStream) {\n                var _a, _b;\n                _this.accessAllowed = true;\n                _this.accessDenied = false;\n                if (typeof MediaStreamTrack !== 'undefined' && _this.properties.audioSource instanceof MediaStreamTrack) {\n                  mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n                  mediaStream.addTrack(_this.properties.audioSource);\n                }\n                if (typeof MediaStreamTrack !== 'undefined' && _this.properties.videoSource instanceof MediaStreamTrack) {\n                  mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n                  mediaStream.addTrack(_this.properties.videoSource);\n                }\n                // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n                if (!!mediaStream.getAudioTracks()[0]) {\n                  var enabled = _this.stream.audioActive !== undefined && _this.stream.audioActive !== null ? _this.stream.audioActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n                  mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!mediaStream.getVideoTracks()[0]) {\n                  var enabled = _this.stream.videoActive !== undefined && _this.stream.videoActive !== null ? _this.stream.videoActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n                  mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n                // Set Content Hint on all MediaStreamTracks\n                for (var _i = 0, _c = mediaStream.getAudioTracks(); _i < _c.length; _i++) {\n                  var track = _c[_i];\n                  if (!((_a = track.contentHint) === null || _a === void 0 ? void 0 : _a.length)) {\n                    // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n                    // https://w3c.github.io/mst-content-hint/#audio-content-hints\n                    track.contentHint = '';\n                    logger.info(\"Audio track Content Hint set: '\".concat(track.contentHint, \"'\"));\n                  }\n                }\n                for (var _d = 0, _e = mediaStream.getVideoTracks(); _d < _e.length; _d++) {\n                  var track = _e[_d];\n                  if (!((_b = track.contentHint) === null || _b === void 0 ? void 0 : _b.length)) {\n                    // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n                    // https://w3c.github.io/mst-content-hint/#video-content-hints\n                    switch (_this.stream.typeOfVideo) {\n                      case TypeOfVideo_1.TypeOfVideo.SCREEN:\n                        track.contentHint = 'detail';\n                        break;\n                      case TypeOfVideo_1.TypeOfVideo.CUSTOM:\n                        logger.warn('CUSTOM type video track was provided without Content Hint!');\n                        track.contentHint = 'motion';\n                        break;\n                      case TypeOfVideo_1.TypeOfVideo.CAMERA:\n                      case TypeOfVideo_1.TypeOfVideo.IPCAM:\n                      default:\n                        track.contentHint = 'motion';\n                        break;\n                    }\n                    logger.info(\"Video track Content Hint set: '\".concat(track.contentHint, \"'\"));\n                  }\n                }\n                _this.initializeVideoReference(mediaStream);\n                if (!_this.stream.displayMyRemote()) {\n                  // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n                  // avoid early 'streamPlaying' event\n                  _this.stream.updateMediaStreamInVideos();\n                }\n                delete _this.firstVideoElement;\n                if (_this.stream.isSendVideo()) {\n                  // Has video track\n                  _this.getVideoDimensions().then(function (dimensions) {\n                    _this.stream.videoDimensions = {\n                      width: dimensions.width,\n                      height: dimensions.height\n                    };\n                    if (_this.stream.isSendScreen()) {\n                      // Set interval to listen for screen resize events\n                      _this.screenShareResizeInterval = setInterval(function () {\n                        var settings = mediaStream.getVideoTracks()[0].getSettings();\n                        var newWidth = settings.width;\n                        var newHeight = settings.height;\n                        var widthChanged = newWidth != null && newWidth !== _this.stream.videoDimensions.width;\n                        var heightChanged = newHeight != null && newHeight !== _this.stream.videoDimensions.height;\n                        if (_this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                          _this.openvidu.sendVideoDimensionsChangedEvent(_this, 'screenResized', _this.stream.videoDimensions.width, _this.stream.videoDimensions.height, newWidth || 0, newHeight || 0);\n                        }\n                      }, 650);\n                    }\n                    _this.stream.isLocalStreamReadyToPublish = true;\n                    _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                  });\n                } else {\n                  // Only audio track (no videoDimensions)\n                  _this.stream.isLocalStreamReadyToPublish = true;\n                  _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                }\n                return resolve();\n              };\n              getMediaSuccess = function (mediaStream, definedAudioConstraint) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var audioOnlyStream, error_4;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        if (!(this.stream.isSendScreen() && this.stream.isSendAudio())) return [3 /*break*/, 5];\n                        // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n                        constraintsAux.audio = definedAudioConstraint;\n                        constraintsAux.video = false;\n                        startTime = Date.now();\n                        this.setPermissionDialogTimer(timeForDialogEvent);\n                        _a.label = 1;\n                      case 1:\n                        _a.trys.push([1, 3,, 4]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraintsAux)];\n                      case 2:\n                        audioOnlyStream = _a.sent();\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n                        successCallback(mediaStream);\n                        return [3 /*break*/, 4];\n                      case 3:\n                        error_4 = _a.sent();\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.getAudioTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        errorCallback(this.openvidu.generateAudioDeviceError(error_4, constraints));\n                        return [2 /*return*/];\n                      case 4:\n                        return [3 /*break*/, 6];\n                      case 5:\n                        successCallback(mediaStream);\n                        _a.label = 6;\n                      case 6:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              getMediaError = function (error) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var errorName, errorMessage, _a, mediaStream, error_5, mediaStream, error_6;\n                  return __generator(this, function (_b) {\n                    switch (_b.label) {\n                      case 0:\n                        logger.error(\"getMediaError: \".concat(error.toString()));\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        if (error.name === 'Error') {\n                          // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n                          error.name = error.constructor.name;\n                        }\n                        _a = error.name.toLowerCase();\n                        switch (_a) {\n                          case 'notfounderror':\n                            return [3 /*break*/, 1];\n                          case 'notallowederror':\n                            return [3 /*break*/, 5];\n                          case 'overconstrainederror':\n                            return [3 /*break*/, 6];\n                          case 'aborterror':\n                            return [3 /*break*/, 10];\n                          case 'notreadableerror':\n                            return [3 /*break*/, 10];\n                        }\n                        return [3 /*break*/, 11];\n                      case 1:\n                        _b.trys.push([1, 3,, 4]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                          audio: false,\n                          video: constraints.video\n                        })];\n                      case 2:\n                        mediaStream = _b.sent();\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 4];\n                      case 3:\n                        error_5 = _b.sent();\n                        errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                        errorMessage = error_5.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 4];\n                      case 4:\n                        return [3 /*break*/, 12];\n                      case 5:\n                        errorName = this.stream.isSendScreen() ? OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED : OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 6:\n                        _b.trys.push([6, 8,, 9]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                          audio: false,\n                          video: constraints.video\n                        })];\n                      case 7:\n                        mediaStream = _b.sent();\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        if (error.constraint.toLowerCase() === 'deviceid') {\n                          errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                          errorMessage = \"Audio input device with deviceId '\" + constraints.audio.deviceId.exact + \"' not found\";\n                        } else {\n                          errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                          errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                        }\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 9];\n                      case 8:\n                        error_6 = _b.sent();\n                        if (error_6.constraint.toLowerCase() === 'deviceid') {\n                          errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                          errorMessage = \"Video input device with deviceId '\" + constraints.video.deviceId.exact + \"' not found\";\n                        } else {\n                          errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                          errorMessage = \"Video input device doesn't support the value passed for constraint '\" + error_6.constraint + \"'\";\n                        }\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 9];\n                      case 9:\n                        return [3 /*break*/, 12];\n                      case 10:\n                        errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 11:\n                        errorName = OpenViduError_1.OpenViduErrorName.GENERIC_ERROR;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 12:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              _c.label = 1;\n            case 1:\n              _c.trys.push([1, 14,, 15]);\n              return [4 /*yield*/, this.openvidu.generateMediaConstraints(this.properties)];\n            case 2:\n              myConstraints = _c.sent();\n              if (!(!!myConstraints.videoTrack && !!myConstraints.audioTrack || !!myConstraints.audioTrack && ((_a = myConstraints.constraints) === null || _a === void 0 ? void 0 : _a.video) === false || !!myConstraints.videoTrack && ((_b = myConstraints.constraints) === null || _b === void 0 ? void 0 : _b.audio) === false)) return [3 /*break*/, 3];\n              // No need to call getUserMedia at all. MediaStreamTracks already provided\n              successCallback(this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), this.stream));\n              return [3 /*break*/, 13];\n            case 3:\n              constraints = myConstraints.constraints;\n              outboundStreamOptions = {\n                mediaConstraints: constraints,\n                publisherProperties: this.properties\n              };\n              this.stream.setOutboundStreamOptions(outboundStreamOptions);\n              definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n              constraintsAux.audio = this.stream.isSendScreen() ? false : definedAudioConstraint;\n              constraintsAux.video = constraints.video;\n              startTime = Date.now();\n              this.setPermissionDialogTimer(timeForDialogEvent);\n              _c.label = 4;\n            case 4:\n              _c.trys.push([4, 11,, 13]);\n              if (!(this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron())) return [3 /*break*/, 7];\n              return [4 /*yield*/, navigator.mediaDevices['getDisplayMedia']({\n                video: true\n              })];\n            case 5:\n              mediaStream = _c.sent();\n              this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n              return [4 /*yield*/, getMediaSuccess(mediaStream, definedAudioConstraint)];\n            case 6:\n              _c.sent();\n              return [3 /*break*/, 10];\n            case 7:\n              this.stream.lastVideoTrackConstraints = constraintsAux.video;\n              return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraintsAux)];\n            case 8:\n              mediaStream = _c.sent();\n              this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, this.stream);\n              return [4 /*yield*/, getMediaSuccess(mediaStream, definedAudioConstraint)];\n            case 9:\n              _c.sent();\n              _c.label = 10;\n            case 10:\n              return [3 /*break*/, 13];\n            case 11:\n              error_2 = _c.sent();\n              return [4 /*yield*/, getMediaError(error_2)];\n            case 12:\n              _c.sent();\n              return [3 /*break*/, 13];\n            case 13:\n              return [3 /*break*/, 15];\n            case 14:\n              error_3 = _c.sent();\n              errorCallback(error_3);\n              return [3 /*break*/, 15];\n            case 15:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.replaceTrackAux = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trackOriginalEnabledValue, error_7;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            trackOriginalEnabledValue = track.enabled;\n            if (track.kind === 'video') {\n              track.enabled = this.stream.videoActive;\n            } else if (track.kind === 'audio') {\n              track.enabled = this.stream.audioActive;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n            if (!this.stream.isLocalStreamPublished) return [3 /*break*/, 3];\n            // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n            this.replaceTrackInMediaStream(track, updateLastConstraints);\n            return [4 /*yield*/, this.replaceTrackInRtcRtpSender(track)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            // Publisher not published. Simply replace the track on the local MediaStream\n            return [2 /*return*/, this.replaceTrackInMediaStream(track, updateLastConstraints)];\n          case 4:\n            return [3 /*break*/, 6];\n          case 5:\n            error_7 = _a.sent();\n            track.enabled = trackOriginalEnabledValue;\n            throw error_7;\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   *\n   * To obtain the videoDimensions we wait for the video reference to have enough metadata\n   * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n   * use the HTMLVideoElement properties videoWidth and videoHeight\n   */\n  Publisher.prototype.getVideoDimensions = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n      var requiresDomInsertion = (platform.isIonicIos() || platform.isIOSWithSafari()) && _this.videoReference.readyState < 1;\n      var loadedmetadataListener;\n      var resolveDimensions = function () {\n        var width;\n        var height;\n        if (typeof _this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n          var settings = _this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n          width = settings.width || _this.videoReference.videoWidth;\n          height = settings.height || _this.videoReference.videoHeight;\n        } else {\n          logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n          width = _this.videoReference.videoWidth;\n          height = _this.videoReference.videoHeight;\n        }\n        if (loadedmetadataListener != null) {\n          _this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n        }\n        if (requiresDomInsertion) {\n          document.body.removeChild(_this.videoReference);\n        }\n        return resolve({\n          width: width,\n          height: height\n        });\n      };\n      if (_this.videoReference.readyState >= 1) {\n        // The video already has metadata available\n        // No need of loadedmetadata event\n        resolveDimensions();\n      } else {\n        // The video does not have metadata available yet\n        // Must listen to loadedmetadata event\n        loadedmetadataListener = function () {\n          if (!_this.videoReference.videoWidth) {\n            var interval_1 = setInterval(function () {\n              if (!!_this.videoReference.videoWidth) {\n                clearInterval(interval_1);\n                resolveDimensions();\n              }\n            }, 40);\n          } else {\n            resolveDimensions();\n          }\n        };\n        _this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n        if (requiresDomInsertion) {\n          document.body.appendChild(_this.videoReference);\n        }\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.reestablishStreamPlayingEvent = function () {\n    if (this.ee.getListeners('streamPlaying').length > 0) {\n      this.addPlayEventToFirstVideo();\n    }\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.initializeVideoReference = function (mediaStream) {\n    this.videoReference = document.createElement('video');\n    this.videoReference.style.display = 'none';\n    this.videoReference.muted = true;\n    this.videoReference.autoplay = true;\n    this.videoReference.controls = false;\n    if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n      this.videoReference.playsInline = true;\n    }\n    this.stream.setMediaStream(mediaStream);\n    if (!!this.firstVideoElement) {\n      this.createVideoElement(this.firstVideoElement.targetElement, this.properties.insertMode);\n    }\n    this.videoReference.srcObject = this.stream.getMediaStream();\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.replaceTrackInMediaStream = function (track, updateLastConstraints) {\n    var mediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n    var removedTrack;\n    if (track.kind === 'video') {\n      removedTrack = mediaStream.getVideoTracks()[0];\n      if (updateLastConstraints) {\n        this.stream.lastVideoTrackConstraints = track.getConstraints();\n      }\n    } else {\n      removedTrack = mediaStream.getAudioTracks()[0];\n    }\n    removedTrack.enabled = false;\n    removedTrack.stop();\n    mediaStream.removeTrack(removedTrack);\n    mediaStream.addTrack(track);\n    var trackInfo = {\n      oldLabel: (removedTrack === null || removedTrack === void 0 ? void 0 : removedTrack.label) || '',\n      newLabel: (track === null || track === void 0 ? void 0 : track.label) || ''\n    };\n    if (track.kind === 'video' && updateLastConstraints) {\n      this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n      this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'videoTrack');\n      if (this.stream.isLocalStreamPublished) {\n        this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n      }\n    } else if (track.kind === 'audio' && updateLastConstraints) {\n      this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'audioTrack');\n    }\n    if (track.kind === 'audio') {\n      this.stream.disableHarkSpeakingEvent(false);\n      this.stream.disableHarkStoppedSpeakingEvent(false);\n      this.stream.disableHarkVolumeChangeEvent(false);\n      this.stream.initHarkEvents();\n    }\n  };\n  /* Private methods */\n  Publisher.prototype.setPermissionDialogTimer = function (waitTime) {\n    var _this = this;\n    this.permissionDialogTimeout = setTimeout(function () {\n      _this.emitEvent('accessDialogOpened', []);\n    }, waitTime);\n  };\n  Publisher.prototype.clearPermissionDialogTimer = function (startTime, waitTime) {\n    clearTimeout(this.permissionDialogTimeout);\n    if (Date.now() - startTime > waitTime) {\n      // Permission dialog was shown and now is closed\n      this.emitEvent('accessDialogClosed', []);\n    }\n  };\n  Publisher.prototype.replaceTrackInRtcRtpSender = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      var senders, sender;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            senders = this.stream.getRTCPeerConnection().getSenders();\n            if (track.kind === 'video') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'video';\n              });\n              if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n              }\n            } else if (track.kind === 'audio') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'audio';\n              });\n              if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n              }\n            } else {\n              throw new Error('Unknown track kind ' + track.kind);\n            }\n            return [4 /*yield*/, sender.replaceTrack(track)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return Publisher;\n}(StreamManager_1.StreamManager);\nexports.Publisher = Publisher;","map":{"version":3,"names":["Session_1","require","Stream_1","StreamManager_1","StreamEvent_1","StreamPropertyChangedEvent_1","OpenViduError_1","OpenViduLogger_1","Platform_1","TypeOfVideo_1","logger","OpenViduLogger","getInstance","platform","Publisher","_super","__extends","targEl","properties","openvidu","_this","call","Stream","session","Session","publisherProperties","mediaConstraints","accessAllowed","isSubscribedToRemote","accessDenied","PlatformUtils","stream","ee","on","reason","isLocalStreamPublished","streamEvent","StreamEvent","emitEvent","callDefaultBehavior","prototype","publishAudio","enabled","audioActive","affectedMediaStream","displayMyRemote","localMediaStreamWhenSubscribedToRemote","getMediaStream","getAudioTracks","forEach","track","streamId","sendRequest","property","newValue","error","response","StreamPropertyChangedEvent","sendVideoData","streamManager","info","publishVideo","resource","Promise","resolve","reject","__awaiter","videoActive","affectedMediaStream_1","mustRestartMediaStream_1","getVideoTracks","stop","readyState","filter","type","startsWith","lastVBFilter","removeFilterAux","_a","sent","oldVideoTrack","removeTrack","replaceVideoTrack","tr","addTrack","replaceTrackInRtcRtpSender","setTimeout","options","lastExecMethod","method","Object","assign","params","applyFilter","MediaStreamTrack","navigator","mediaDevices","getUserMedia","audio","video","lastVideoTrackConstraints","mediaStream","error_1","subscribeToRemote","value","undefined","subscribeToMyRemote","handler","once","off","replaceTrack","replaceTrackAux","initialize","constraints","constraintsAux","timeForDialogEvent","errorCallback","openViduError","concat","name","message","successCallback","audioSource","videoSource","outboundStreamOpts","_i","_c","length","contentHint","_d","_e","_b","typeOfVideo","TypeOfVideo","SCREEN","CUSTOM","warn","CAMERA","IPCAM","initializeVideoReference","updateMediaStreamInVideos","firstVideoElement","isSendVideo","getVideoDimensions","then","dimensions","videoDimensions","width","height","isSendScreen","screenShareResizeInterval","setInterval","settings","getSettings","newWidth","newHeight","widthChanged","heightChanged","sendVideoDimensionsChangedEvent","isLocalStreamReadyToPublish","getMediaSuccess","definedAudioConstraint","clearPermissionDialogTimer","startTime","isSendAudio","Date","now","setPermissionDialogTimer","audioOnlyStream","generateAudioDeviceError","error_4","getMediaError","toString","constructor","toLowerCase","errorName","OpenViduErrorName","INPUT_AUDIO_DEVICE_NOT_FOUND","errorMessage","OpenViduError","INPUT_VIDEO_DEVICE_NOT_FOUND","error_5","SCREEN_CAPTURE_DENIED","DEVICE_ACCESS_DENIED","constraint","deviceId","exact","PUBLISHER_PROPERTIES_ERROR","error_6","DEVICE_ALREADY_IN_USE","GENERIC_ERROR","generateMediaConstraints","myConstraints","videoTrack","audioTrack","addAlreadyProvidedTracks","MediaStream","outboundStreamOptions","setOutboundStreamOptions","isElectron","error_2","error_3","updateLastConstraints","trackOriginalEnabledValue","kind","replaceTrackInMediaStream","error_7","requiresDomInsertion","isIonicIos","isIOSWithSafari","videoReference","loadedmetadataListener","resolveDimensions","videoWidth","videoHeight","getDescription","removeEventListener","document","body","removeChild","interval_1","clearInterval","addEventListener","appendChild","reestablishStreamPlayingEvent","getListeners","addPlayEventToFirstVideo","createElement","style","display","muted","autoplay","controls","isSafariBrowser","isIPhoneOrIPad","isChromeMobileBrowser","isEdgeMobileBrowser","isOperaMobileBrowser","isFirefoxMobileBrowser","playsInline","setMediaStream","createVideoElement","targetElement","insertMode","srcObject","removedTrack","getConstraints","trackInfo","oldLabel","label","newLabel","sendNewVideoDimensionsIfRequired","sendTrackChangedEvent","disableHarkSpeakingEvent","disableHarkStoppedSpeakingEvent","disableHarkVolumeChangeEvent","initHarkEvents","waitTime","permissionDialogTimeout","clearTimeout","senders","getRTCPeerConnection","getSenders","sender","find","s","Error","StreamManager","exports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenVidu\\Publisher.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { OpenVidu } from './OpenVidu';\nimport { Session } from './Session';\nimport { Stream } from './Stream';\nimport { StreamManager } from './StreamManager';\nimport { PublisherProperties } from '../OpenViduInternal/Interfaces/Public/PublisherProperties';\nimport { PublisherEventMap } from '../OpenViduInternal/Events/EventMap/PublisherEventMap';\nimport { StreamEvent } from '../OpenViduInternal/Events/StreamEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { VideoInsertMode } from '../OpenViduInternal/Enums/VideoInsertMode';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\nimport { StreamEventReason } from '../OpenViduInternal/Events/Types/Types';\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with {@link OpenVidu.initPublisher} method.\n *\n * See available event listeners at {@link PublisherEventMap}.\n */\nexport class Publisher extends StreamManager {\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n    accessAllowed = false;\n\n    /**\n     * Whether you have called {@link Publisher.subscribeToRemote} with value `true` or `false` (*false* by default)\n     */\n    isSubscribedToRemote = false;\n\n    /**\n     * The {@link Session} to which the Publisher belongs\n     */\n    session: Session; // Initialized by Session.publish(Publisher)\n\n    private accessDenied = false;\n    protected properties: PublisherProperties;\n    private permissionDialogTimeout: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    openvidu: OpenVidu;\n    /**\n     * @hidden\n     */\n    videoReference: HTMLVideoElement;\n    /**\n     * @hidden\n     */\n    screenShareResizeInterval: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    constructor(targEl: string | HTMLElement | undefined, properties: PublisherProperties, openvidu: OpenVidu) {\n        super(\n            new Stream(!!openvidu.session ? openvidu.session : new Session(openvidu), {\n                publisherProperties: properties,\n                mediaConstraints: {}\n            }),\n            targEl\n        );\n        platform = PlatformUtils.getInstance();\n        this.properties = properties;\n        this.openvidu = openvidu;\n\n        this.stream.ee.on('local-stream-destroyed', (reason: StreamEventReason) => {\n            this.stream.isLocalStreamPublished = false;\n            const streamEvent = new StreamEvent(true, this, 'streamDestroyed', this.stream, reason);\n            this.emitEvent('streamDestroyed', [streamEvent]);\n            streamEvent.callDefaultBehavior();\n        });\n    }\n\n    /**\n     * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The {@link Publisher} object of the local participant will also dispatch the exact same event\n     *\n     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See {@link StreamPropertyChangedEvent} to learn more.\n     *\n     * @param enabled `true` to publish the audio stream, `false` to unpublish it\n     */\n    publishAudio(enabled: boolean): void {\n        if (this.stream.audioActive !== enabled) {\n            const affectedMediaStream: MediaStream = this.stream.displayMyRemote()\n                ? this.stream.localMediaStreamWhenSubscribedToRemote!\n                : this.stream.getMediaStream();\n            affectedMediaStream.getAudioTracks().forEach((track) => {\n                track.enabled = enabled;\n            });\n            if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest(\n                    'streamPropertyChanged',\n                    {\n                        streamId: this.stream.streamId,\n                        property: 'audioActive',\n                        newValue: enabled,\n                        reason: 'publishAudio'\n                    },\n                    (error, response) => {\n                        if (error) {\n                            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                        } else {\n                            this.session.emitEvent('streamPropertyChanged', [\n                                new StreamPropertyChangedEvent(this.session, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')\n                            ]);\n                            this.emitEvent('streamPropertyChanged', [\n                                new StreamPropertyChangedEvent(this, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')\n                            ]);\n                            this.session.sendVideoData(this.stream.streamManager);\n                        }\n                    }\n                );\n            }\n            this.stream.audioActive = enabled;\n            logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n        }\n    }\n\n    /**\n     * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The {@link Publisher} object of the local participant will also dispatch the exact same event\n     *\n     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See {@link StreamPropertyChangedEvent} to learn more.\n     *\n     * @param enabled `true` to publish the video stream, `false` to unpublish it\n     * @param resource\n     * \n     * If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n     * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n     * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.\n     * \n     * If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n     * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n     * will be used instead.\n     */\n    publishVideo<T extends boolean>(enabled: T, resource?: T extends false ? boolean : MediaStreamTrack): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            if (this.stream.videoActive !== enabled) {\n                const affectedMediaStream: MediaStream = this.stream.displayMyRemote()\n                    ? this.stream.localMediaStreamWhenSubscribedToRemote!\n                    : this.stream.getMediaStream();\n                let mustRestartMediaStream = false;\n                affectedMediaStream.getVideoTracks().forEach((track) => {\n                    track.enabled = enabled;\n                    if (!enabled && resource === true) {\n                        track.stop();\n                    } else if (enabled && track.readyState === 'ended') {\n                        // Resource was freed\n                        mustRestartMediaStream = true;\n                    }\n                });\n\n                // There is a Virtual Background filter applied that must be removed in case the hardware must be freed\n                if (!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:')) {\n                    this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n                    await this.stream.removeFilterAux(true);\n                }\n\n                if (mustRestartMediaStream) {\n                    const oldVideoTrack = affectedMediaStream.getVideoTracks()[0];\n                    affectedMediaStream.removeTrack(oldVideoTrack);\n\n                    const replaceVideoTrack = async (tr: MediaStreamTrack) => {\n                        affectedMediaStream.addTrack(tr);\n                        if (this.stream.isLocalStreamPublished) {\n                            await this.replaceTrackInRtcRtpSender(tr);\n                        }\n                        if (!!this.stream.lastVBFilter) {\n                            setTimeout(async () => {\n                                let options = this.stream.lastVBFilter!.options;\n                                const lastExecMethod = this.stream.lastVBFilter!.lastExecMethod;\n                                if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                    options = Object.assign({}, options, lastExecMethod.params);\n                                }\n                                await this.stream.applyFilter(this.stream.lastVBFilter!.type, options);\n                                delete this.stream.lastVBFilter;\n                            }, 1);\n                        }\n                    };\n\n                    if (!!resource && resource instanceof MediaStreamTrack) {\n                        await replaceVideoTrack(resource);\n                    } else {\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: this.stream.lastVideoTrackConstraints\n                            });\n                            await replaceVideoTrack(mediaStream.getVideoTracks()[0]);\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                }\n\n                if (!!this.session && !!this.stream.streamId) {\n                    this.session.openvidu.sendRequest(\n                        'streamPropertyChanged',\n                        {\n                            streamId: this.stream.streamId,\n                            property: 'videoActive',\n                            newValue: enabled,\n                            reason: 'publishVideo'\n                        },\n                        (error, response) => {\n                            if (error) {\n                                logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                            } else {\n                                this.session.emitEvent('streamPropertyChanged', [\n                                    new StreamPropertyChangedEvent(\n                                        this.session,\n                                        this.stream,\n                                        'videoActive',\n                                        enabled,\n                                        !enabled,\n                                        'publishVideo'\n                                    )\n                                ]);\n                                this.emitEvent('streamPropertyChanged', [\n                                    new StreamPropertyChangedEvent(this, this.stream, 'videoActive', enabled, !enabled, 'publishVideo')\n                                ]);\n                                this.session.sendVideoData(this.stream.streamManager);\n                            }\n                        }\n                    );\n                }\n                this.stream.videoActive = enabled;\n                logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n                return resolve();\n            }\n        });\n    }\n\n    /**\n     * Call this method before {@link Session.publish} if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n     */\n    subscribeToRemote(value?: boolean): void {\n        value = value !== undefined ? value : true;\n        this.isSubscribedToRemote = value;\n        this.stream.subscribeToMyRemote(value);\n    }\n\n    /**\n     * See {@link EventDispatcher.on}\n     */\n    on<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n        super.on(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.on('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * See {@link EventDispatcher.once}\n     */\n    once<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n        super.once(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.once('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * See {@link EventDispatcher.off}\n     */\n    off<K extends keyof PublisherEventMap>(type: K, handler?: (event: PublisherEventMap[K]) => void): this {\n        super.off(<any>type, handler);\n        return this;\n    }\n\n    /**\n     * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n     * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n     * and publishing the new one).\n     *\n     * You can get this new MediaStreamTrack by using the native Web API or simply with {@link OpenVidu.getUserMedia} method.\n     *\n     * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n     * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n     * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n     *\n     * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n     * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n     */\n    async replaceTrack(track: MediaStreamTrack): Promise<void> {\n        return this.replaceTrackAux(track, true);\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    initialize(): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            let constraints: MediaStreamConstraints = {};\n            let constraintsAux: MediaStreamConstraints = {};\n            const timeForDialogEvent = 2000;\n            let startTime;\n\n            const errorCallback = (openViduError: OpenViduError) => {\n                this.accessDenied = true;\n                this.accessAllowed = false;\n                logger.error(`Publisher initialization failed. ${openViduError.name}: ${openViduError.message}`);\n                return reject(openViduError);\n            };\n\n            const successCallback = (mediaStream: MediaStream) => {\n                this.accessAllowed = true;\n                this.accessDenied = false;\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.audioSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n                    mediaStream.addTrack(<MediaStreamTrack>this.properties.audioSource);\n                }\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.videoSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n                    mediaStream.addTrack(<MediaStreamTrack>this.properties.videoSource);\n                }\n\n                // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n                if (!!mediaStream.getAudioTracks()[0]) {\n                    const enabled =\n                        this.stream.audioActive !== undefined && this.stream.audioActive !== null\n                            ? this.stream.audioActive\n                            : !!this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n                    mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!mediaStream.getVideoTracks()[0]) {\n                    const enabled =\n                        this.stream.videoActive !== undefined && this.stream.videoActive !== null\n                            ? this.stream.videoActive\n                            : !!this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n                    mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n\n                // Set Content Hint on all MediaStreamTracks\n                for (const track of mediaStream.getAudioTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n                        // https://w3c.github.io/mst-content-hint/#audio-content-hints\n                        track.contentHint = '';\n                        logger.info(`Audio track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n                for (const track of mediaStream.getVideoTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n                        // https://w3c.github.io/mst-content-hint/#video-content-hints\n                        switch (this.stream.typeOfVideo) {\n                            case TypeOfVideo.SCREEN:\n                                track.contentHint = 'detail';\n                                break;\n                            case TypeOfVideo.CUSTOM:\n                                logger.warn('CUSTOM type video track was provided without Content Hint!');\n                                track.contentHint = 'motion';\n                                break;\n                            case TypeOfVideo.CAMERA:\n                            case TypeOfVideo.IPCAM:\n                            default:\n                                track.contentHint = 'motion';\n                                break;\n                        }\n                        logger.info(`Video track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n\n                this.initializeVideoReference(mediaStream);\n\n                if (!this.stream.displayMyRemote()) {\n                    // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n                    // avoid early 'streamPlaying' event\n                    this.stream.updateMediaStreamInVideos();\n                }\n                delete this.firstVideoElement;\n\n                if (this.stream.isSendVideo()) {\n                    // Has video track\n                    this.getVideoDimensions().then((dimensions) => {\n                        this.stream.videoDimensions = {\n                            width: dimensions.width,\n                            height: dimensions.height\n                        };\n\n                        if (this.stream.isSendScreen()) {\n                            // Set interval to listen for screen resize events\n                            this.screenShareResizeInterval = setInterval(() => {\n                                const settings: MediaTrackSettings = mediaStream.getVideoTracks()[0].getSettings();\n                                const newWidth = settings.width;\n                                const newHeight = settings.height;\n                                const widthChanged = newWidth != null && newWidth !== this.stream.videoDimensions.width;\n                                const heightChanged = newHeight != null && newHeight !== this.stream.videoDimensions.height;\n                                if (this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                                    this.openvidu.sendVideoDimensionsChangedEvent(\n                                        this,\n                                        'screenResized',\n                                        this.stream.videoDimensions.width,\n                                        this.stream.videoDimensions.height,\n                                        newWidth || 0,\n                                        newHeight || 0\n                                    );\n                                }\n                            }, 650);\n                        }\n\n                        this.stream.isLocalStreamReadyToPublish = true;\n                        this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                    });\n                } else {\n                    // Only audio track (no videoDimensions)\n                    this.stream.isLocalStreamReadyToPublish = true;\n                    this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                }\n\n                return resolve();\n            };\n\n            const getMediaSuccess = async (mediaStream: MediaStream, definedAudioConstraint) => {\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (this.stream.isSendScreen() && this.stream.isSendAudio()) {\n                    // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n                    constraintsAux.audio = definedAudioConstraint;\n                    constraintsAux.video = false;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    try {\n                        const audioOnlyStream = await navigator.mediaDevices.getUserMedia(constraintsAux);\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n                        successCallback(mediaStream);\n                    } catch (error) {\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.getAudioTracks().forEach((track) => {\n                            track.stop();\n                        });\n                        mediaStream.getVideoTracks().forEach((track) => {\n                            track.stop();\n                        });\n                        errorCallback(this.openvidu.generateAudioDeviceError(error, constraints));\n                        return;\n                    }\n                } else {\n                    successCallback(mediaStream);\n                }\n            };\n\n            const getMediaError = async (error) => {\n                logger.error(`getMediaError: ${error.toString()}`);\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (error.name === 'Error') {\n                    // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n                    error.name = error.constructor.name;\n                }\n                let errorName, errorMessage;\n                switch (error.name.toLowerCase()) {\n                    case 'notfounderror':\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: constraints.video\n                            });\n                            mediaStream.getVideoTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                            errorMessage = error.toString();\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        } catch (error) {\n                            errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                            errorMessage = error.toString();\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        }\n\n                        break;\n                    case 'notallowederror':\n                        errorName = this.stream.isSendScreen()\n                            ? OpenViduErrorName.SCREEN_CAPTURE_DENIED\n                            : OpenViduErrorName.DEVICE_ACCESS_DENIED;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    case 'overconstrainederror':\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: constraints.video\n                            });\n                            mediaStream.getVideoTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            if (error.constraint.toLowerCase() === 'deviceid') {\n                                errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                                errorMessage =\n                                    \"Audio input device with deviceId '\" +\n                                    (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.audio).deviceId!!).exact +\n                                    \"' not found\";\n                            } else {\n                                errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                errorMessage =\n                                    \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                            }\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        } catch (error) {\n                            if (error.constraint.toLowerCase() === 'deviceid') {\n                                errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                                errorMessage =\n                                    \"Video input device with deviceId '\" +\n                                    (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.video).deviceId!!).exact +\n                                    \"' not found\";\n                            } else {\n                                errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                errorMessage =\n                                    \"Video input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                            }\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        }\n\n                        break;\n                    case 'aborterror':\n                    case 'notreadableerror':\n                        errorName = OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    default:\n                        errorName = OpenViduErrorName.GENERIC_ERROR;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                }\n            };\n\n            try {\n                const myConstraints = await this.openvidu.generateMediaConstraints(this.properties);\n                if (\n                    (!!myConstraints.videoTrack && !!myConstraints.audioTrack) ||\n                    (!!myConstraints.audioTrack && myConstraints.constraints?.video === false) ||\n                    (!!myConstraints.videoTrack && myConstraints.constraints?.audio === false)\n                ) {\n                    // No need to call getUserMedia at all. MediaStreamTracks already provided\n                    successCallback(this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), this.stream));\n                } else {\n                    constraints = myConstraints.constraints;\n\n                    const outboundStreamOptions = {\n                        mediaConstraints: constraints,\n                        publisherProperties: this.properties\n                    };\n                    this.stream.setOutboundStreamOptions(outboundStreamOptions);\n\n                    const definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n                    constraintsAux.audio = this.stream.isSendScreen() ? false : definedAudioConstraint;\n                    constraintsAux.video = constraints.video;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    try {\n                        if (this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n                            const mediaStream = await navigator.mediaDevices['getDisplayMedia']({ video: true });\n                            this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n                            await getMediaSuccess(mediaStream, definedAudioConstraint);\n                        } else {\n                            this.stream.lastVideoTrackConstraints = constraintsAux.video;\n                            const mediaStream = await navigator.mediaDevices.getUserMedia(constraintsAux);\n                            this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, this.stream);\n                            await getMediaSuccess(mediaStream, definedAudioConstraint);\n                        }\n                    } catch (error) {\n                        await getMediaError(error);\n                    }\n                }\n            } catch (error) {\n                errorCallback(error);\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    async replaceTrackAux(track: MediaStreamTrack, updateLastConstraints: boolean): Promise<void> {\n        // Set field \"enabled\" of the new track to the previous value\n        const trackOriginalEnabledValue: boolean = track.enabled;\n        if (track.kind === 'video') {\n            track.enabled = this.stream.videoActive;\n        } else if (track.kind === 'audio') {\n            track.enabled = this.stream.audioActive;\n        }\n        try {\n            if (this.stream.isLocalStreamPublished) {\n                // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n                // If it has not been published yet, replacing it on the MediaStream object is enough\n                this.replaceTrackInMediaStream(track, updateLastConstraints);\n                return await this.replaceTrackInRtcRtpSender(track);\n            } else {\n                // Publisher not published. Simply replace the track on the local MediaStream\n                return this.replaceTrackInMediaStream(track, updateLastConstraints);\n            }\n        } catch (error) {\n            track.enabled = trackOriginalEnabledValue;\n            throw error;\n        }\n    }\n\n    /**\n     * @hidden\n     *\n     * To obtain the videoDimensions we wait for the video reference to have enough metadata\n     * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n     * use the HTMLVideoElement properties videoWidth and videoHeight\n     */\n    getVideoDimensions(): Promise<{ width: number; height: number }> {\n        return new Promise((resolve, reject) => {\n            // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n            const requiresDomInsertion: boolean = (platform.isIonicIos() || platform.isIOSWithSafari()) && (this.videoReference.readyState < 1);\n\n            let loadedmetadataListener;\n            const resolveDimensions = () => {\n                let width: number;\n                let height: number;\n                if (typeof this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n                    const settings = this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n                    width = settings.width || this.videoReference.videoWidth;\n                    height = settings.height || this.videoReference.videoHeight;\n                } else {\n                    logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n                    width = this.videoReference.videoWidth;\n                    height = this.videoReference.videoHeight;\n                }\n\n                if (loadedmetadataListener != null) {\n                    this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n                }\n                if (requiresDomInsertion) {\n                    document.body.removeChild(this.videoReference);\n                }\n\n                return resolve({ width, height });\n            };\n\n            if (this.videoReference.readyState >= 1) {\n                // The video already has metadata available\n                // No need of loadedmetadata event\n                resolveDimensions();\n            } else {\n                // The video does not have metadata available yet\n                // Must listen to loadedmetadata event\n                loadedmetadataListener = () => {\n                    if (!this.videoReference.videoWidth) {\n                        let interval = setInterval(() => {\n                            if (!!this.videoReference.videoWidth) {\n                                clearInterval(interval);\n                                resolveDimensions();\n                            }\n                        }, 40);\n                    } else {\n                        resolveDimensions();\n                    }\n                };\n                this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n                if (requiresDomInsertion) {\n                    document.body.appendChild(this.videoReference);\n                }\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    reestablishStreamPlayingEvent() {\n        if (this.ee.getListeners('streamPlaying').length > 0) {\n            this.addPlayEventToFirstVideo();\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initializeVideoReference(mediaStream: MediaStream) {\n        this.videoReference = document.createElement('video');\n        this.videoReference.style.display = 'none';\n        this.videoReference.muted = true;\n        this.videoReference.autoplay = true;\n        this.videoReference.controls = false;\n        if (\n            platform.isSafariBrowser() ||\n            (platform.isIPhoneOrIPad() &&\n                (platform.isChromeMobileBrowser() ||\n                    platform.isEdgeMobileBrowser() ||\n                    platform.isOperaMobileBrowser() ||\n                    platform.isFirefoxMobileBrowser()))\n        ) {\n            this.videoReference.playsInline = true;\n        }\n        this.stream.setMediaStream(mediaStream);\n        if (!!this.firstVideoElement) {\n            this.createVideoElement(this.firstVideoElement.targetElement, <VideoInsertMode>this.properties.insertMode);\n        }\n        this.videoReference.srcObject = this.stream.getMediaStream();\n    }\n\n    /**\n     * @hidden\n     */\n    replaceTrackInMediaStream(track: MediaStreamTrack, updateLastConstraints: boolean): void {\n        const mediaStream: MediaStream = this.stream.displayMyRemote()\n            ? this.stream.localMediaStreamWhenSubscribedToRemote!\n            : this.stream.getMediaStream();\n        let removedTrack: MediaStreamTrack;\n        if (track.kind === 'video') {\n            removedTrack = mediaStream.getVideoTracks()[0];\n            if (updateLastConstraints) {\n                this.stream.lastVideoTrackConstraints = track.getConstraints();\n            }\n        } else {\n            removedTrack = mediaStream.getAudioTracks()[0];\n        }\n        removedTrack.enabled = false;\n        removedTrack.stop();\n        mediaStream.removeTrack(removedTrack);\n        mediaStream.addTrack(track);\n        const trackInfo = {\n            oldLabel: removedTrack?.label || '',\n            newLabel: track?.label || ''\n        };\n        if (track.kind === 'video' && updateLastConstraints) {\n            this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n            this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'videoTrack');\n            if (this.stream.isLocalStreamPublished) {\n                this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n            }\n        } else if (track.kind === 'audio' && updateLastConstraints) {\n            this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'audioTrack');\n        }\n        if (track.kind === 'audio') {\n            this.stream.disableHarkSpeakingEvent(false);\n            this.stream.disableHarkStoppedSpeakingEvent(false);\n            this.stream.disableHarkVolumeChangeEvent(false);\n            this.stream.initHarkEvents();\n        }\n    }\n\n    /* Private methods */\n\n    private setPermissionDialogTimer(waitTime: number): void {\n        this.permissionDialogTimeout = setTimeout(() => {\n            this.emitEvent('accessDialogOpened', []);\n        }, waitTime);\n    }\n\n    private clearPermissionDialogTimer(startTime: number, waitTime: number): void {\n        clearTimeout(this.permissionDialogTimeout);\n        if (Date.now() - startTime > waitTime) {\n            // Permission dialog was shown and now is closed\n            this.emitEvent('accessDialogClosed', []);\n        }\n    }\n\n    private async replaceTrackInRtcRtpSender(track: MediaStreamTrack): Promise<void> {\n        const senders: RTCRtpSender[] = this.stream.getRTCPeerConnection().getSenders();\n        let sender: RTCRtpSender | undefined;\n        if (track.kind === 'video') {\n            sender = senders.find((s) => !!s.track && s.track.kind === 'video');\n            if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n            }\n        } else if (track.kind === 'audio') {\n            sender = senders.find((s) => !!s.track && s.track.kind === 'audio');\n            if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n            }\n        } else {\n            throw new Error('Unknown track kind ' + track.kind);\n        }\n        await (sender as RTCRtpSender).replaceTrack(track);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}