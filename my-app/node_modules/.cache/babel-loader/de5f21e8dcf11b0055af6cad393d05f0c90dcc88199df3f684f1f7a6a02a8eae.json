{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\nvar Filter_1 = require(\"./Filter\");\nvar Subscriber_1 = require(\"./Subscriber\");\nvar WebRtcPeer_1 = require(\"../OpenViduInternal/WebRtcPeer/WebRtcPeer\");\nvar WebRtcStats_1 = require(\"../OpenViduInternal/WebRtcStats/WebRtcStats\");\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\nvar PublisherSpeakingEvent_1 = require(\"../OpenViduInternal/Events/PublisherSpeakingEvent\");\nvar StreamManagerEvent_1 = require(\"../OpenViduInternal/Events/StreamManagerEvent\");\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar uuid_1 = require(\"uuid\");\n/**\n * @hidden\n */\nvar hark = require(\"hark\");\n/**\n * @hidden\n */\nvar EventEmitter = require(\"wolfy87-eventemitter\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\nvar Stream = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function Stream(session, options) {\n    var _this = this;\n    this.isSubscribeToRemote = false;\n    /**\n     * @hidden\n     */\n    this.isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n    this.isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n    this.publishedOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.ee = new EventEmitter();\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.session = session;\n    if (options.hasOwnProperty('id')) {\n      // InboundStreamOptions: stream belongs to a Subscriber\n      this.inboundStreamOpts = options;\n      this.streamId = this.inboundStreamOpts.id;\n      this.creationTime = this.inboundStreamOpts.createdAt;\n      this.hasAudio = this.inboundStreamOpts.hasAudio;\n      this.hasVideo = this.inboundStreamOpts.hasVideo;\n      if (this.hasAudio) {\n        this.audioActive = this.inboundStreamOpts.audioActive;\n      }\n      if (this.hasVideo) {\n        this.videoActive = this.inboundStreamOpts.videoActive;\n        this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n        this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n        this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n      }\n      if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n        if (!!this.inboundStreamOpts.filter.lastExecMethod && Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0) {\n          delete this.inboundStreamOpts.filter.lastExecMethod;\n        }\n        this.filter = this.inboundStreamOpts.filter;\n      }\n    } else {\n      // OutboundStreamOptions: stream belongs to a Publisher\n      this.outboundStreamOpts = options;\n      this.hasAudio = this.isSendAudio();\n      this.hasVideo = this.isSendVideo();\n      if (this.hasAudio) {\n        this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n      }\n      if (this.hasVideo) {\n        this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n        this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n        if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n          this.typeOfVideo = TypeOfVideo_1.TypeOfVideo.CUSTOM;\n        } else {\n          this.typeOfVideo = this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n        }\n      }\n      if (!!this.outboundStreamOpts.publisherProperties.filter) {\n        this.filter = this.outboundStreamOpts.publisherProperties.filter;\n      }\n    }\n    this.ee.on('mediastream-updated', function () {\n      var _a;\n      _this.streamManager.updateMediaStream(_this.mediaStream);\n      logger.debug('Video srcObject [' + ((_a = _this.mediaStream) === null || _a === void 0 ? void 0 : _a.id) + '] updated in stream [' + _this.streamId + ']');\n    });\n  }\n  /**\n   * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n   * of a new one, that will apply the same properties.\n   *\n   * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n   * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n   */\n  Stream.prototype.reconnect = function () {\n    return this.reconnectStream('API');\n  };\n  /**\n   * Applies an audio/video filter to the stream.\n   *\n   * @param type Type of filter applied. See {@link Filter.type}\n   * @param options Parameters used to initialize the filter. See {@link Filter.options}\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n   */\n  Stream.prototype.applyFilter = function (type, options) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveApplyFilter, openviduToken_1, tokenParams_1, afterScriptLoaded_1, script, optionsString;\n        var _this = this;\n        return __generator(this, function (_a) {\n          if (!!this.filter) {\n            return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId))];\n          }\n          resolveApplyFilter = function (error, triggerEvent) {\n            if (error) {\n              logger.error('Error applying filter for Stream ' + _this.streamId, error);\n              if (error.code === 401) {\n                return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\"));\n              } else {\n                return reject(error);\n              }\n            } else {\n              logger.info('Filter successfully applied on Stream ' + _this.streamId);\n              var oldValue = _this.filter;\n              _this.filter = new Filter_1.Filter(type, options);\n              _this.filter.stream = _this;\n              if (triggerEvent) {\n                _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n              }\n              return resolve(_this.filter);\n            }\n          };\n          if (type.startsWith('VB:')) {\n            // Client filters\n            if (!this.hasVideo) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The Virtual Background filter requires a video track to be applied'))];\n            }\n            if (!this.mediaStream || this.streamManager.videos.length === 0) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'))];\n            }\n            if (!!this.session.token) {\n              openviduToken_1 = this.session.token;\n            } else {\n              openviduToken_1 = options['token'];\n            }\n            if (!openviduToken_1) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'))];\n            }\n            tokenParams_1 = this.session.getTokenParams(openviduToken_1);\n            if (tokenParams_1.edition !== 'pro' && tokenParams_1.edition !== 'enterprise') {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'))];\n            }\n            openviduToken_1 = encodeURIComponent(btoa(openviduToken_1));\n            logger.info('Applying Virtual Background to stream ' + this.streamId);\n            afterScriptLoaded_1 = function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var id, mediaStreamClone, videoClone, VB, filteredVideo, _a, error_1;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 8,, 9]);\n                      id = this.streamId + '_' + (0, uuid_1.v4)();\n                      mediaStreamClone = this.mediaStream.clone();\n                      videoClone = this.streamManager.videos[0].video.cloneNode(false);\n                      // @ts-ignore\n                      videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                      videoClone.srcObject = mediaStreamClone;\n                      videoClone.muted = true;\n                      this.virtualBackgroundSourceElements = {\n                        videoClone: videoClone,\n                        mediaStreamClone: mediaStreamClone\n                      };\n                      // @ts-ignore\n                      VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false);\n                      // @ts-ignore\n                      VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n                      return [4 /*yield*/, videoClone.play()];\n                    case 1:\n                      _b.sent();\n                      VB = new VirtualBackground.VirtualBackground({\n                        id: id,\n                        openviduServerUrl: new URL(tokenParams_1.httpUri),\n                        openviduToken: openviduToken_1,\n                        inputVideo: videoClone,\n                        inputResolution: '160x96',\n                        outputFramerate: 24\n                      });\n                      filteredVideo = void 0;\n                      _a = type;\n                      switch (_a) {\n                        case 'VB:blur':\n                          return [3 /*break*/, 2];\n                        case 'VB:image':\n                          return [3 /*break*/, 4];\n                      }\n                      return [3 /*break*/, 6];\n                    case 2:\n                      return [4 /*yield*/, VB.backgroundBlur(options)];\n                    case 3:\n                      filteredVideo = _b.sent();\n                      return [3 /*break*/, 7];\n                    case 4:\n                      return [4 /*yield*/, VB.backgroundImage(options)];\n                    case 5:\n                      filteredVideo = _b.sent();\n                      return [3 /*break*/, 7];\n                    case 6:\n                      throw new Error('Unknown Virtual Background filter: ' + type);\n                    case 7:\n                      this.virtualBackgroundSinkElements = {\n                        VB: VB,\n                        video: filteredVideo\n                      };\n                      videoClone.style.display = 'none';\n                      if (this.streamManager.remote) {\n                        this.streamManager.replaceTrackInMediaStream(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      } else {\n                        this.streamManager.replaceTrackAux(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      }\n                      resolveApplyFilter(undefined, false);\n                      return [3 /*break*/, 9];\n                    case 8:\n                      error_1 = _b.sent();\n                      if (error_1.name === OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                        resolveApplyFilter(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error_1.message), false);\n                      } else {\n                        resolveApplyFilter(error_1, false);\n                      }\n                      return [3 /*break*/, 9];\n                    case 9:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            };\n            // @ts-ignore\n            if (typeof VirtualBackground === 'undefined') {\n              script = document.createElement('script');\n              script.type = 'text/javascript';\n              script.src = tokenParams_1.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken_1;\n              script.onload = function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var error_2;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        _a.trys.push([0, 2,, 3]);\n                        return [4 /*yield*/, afterScriptLoaded_1()];\n                      case 1:\n                        _a.sent();\n                        resolve(new Filter_1.Filter(type, options));\n                        return [3 /*break*/, 3];\n                      case 2:\n                        error_2 = _a.sent();\n                        reject(error_2);\n                        return [3 /*break*/, 3];\n                      case 3:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              document.body.appendChild(script);\n            } else {\n              afterScriptLoaded_1().then(function () {\n                return resolve(new Filter_1.Filter(type, options));\n              }).catch(function (error) {\n                return reject(error);\n              });\n            }\n          } else {\n            // Server filters\n            if (!this.session.sessionConnected()) {\n              return [2 /*return*/, reject(this.session.notConnectedError())];\n            }\n            logger.info('Applying server filter to stream ' + this.streamId);\n            options = options != null ? options : {};\n            optionsString = options;\n            if (typeof optionsString !== 'string') {\n              optionsString = JSON.stringify(optionsString);\n            }\n            this.session.openvidu.sendRequest('applyFilter', {\n              streamId: this.streamId,\n              type: type,\n              options: optionsString\n            }, function (error, response) {\n              resolveApplyFilter(error, true);\n            });\n          }\n          return [2 /*return*/];\n        });\n      });\n    });\n  };\n  /**\n   * Removes an audio/video filter previously applied.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n   */\n  Stream.prototype.removeFilter = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.removeFilterAux(false)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n   *\n   * @returns Native RTCPeerConnection Web API object\n   */\n  Stream.prototype.getRTCPeerConnection = function () {\n    return this.webRtcPeer.pc;\n  };\n  /**\n   * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n   *\n   * @returns Native MediaStream Web API object\n   */\n  Stream.prototype.getMediaStream = function () {\n    return this.mediaStream;\n  };\n  /* Hidden methods */\n  /**\n   * @hidden\n   */\n  Stream.prototype.removeFilterAux = function (isDisposing) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveRemoveFilter, mediaStreamClone, error_3;\n        var _this = this;\n        var _a;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              resolveRemoveFilter = function (error, triggerEvent) {\n                if (error) {\n                  delete _this.filter;\n                  logger.error('Error removing filter for Stream ' + _this.streamId, error);\n                  if (error.code === 401) {\n                    return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\"));\n                  } else {\n                    return reject(error);\n                  }\n                } else {\n                  logger.info('Filter successfully removed from Stream ' + _this.streamId);\n                  var oldValue = _this.filter;\n                  delete _this.filter;\n                  if (triggerEvent) {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                    _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                  }\n                  return resolve();\n                }\n              };\n              if (!!!this.filter) return [3 /*break*/, 11];\n              if (!((_a = this.filter) === null || _a === void 0 ? void 0 : _a.type.startsWith('VB:'))) return [3 /*break*/, 9];\n              _b.label = 1;\n            case 1:\n              _b.trys.push([1, 7,, 8]);\n              mediaStreamClone = this.virtualBackgroundSourceElements.mediaStreamClone;\n              if (!!isDisposing) return [3 /*break*/, 5];\n              if (!this.streamManager.remote) return [3 /*break*/, 2];\n              this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false);\n              return [3 /*break*/, 4];\n            case 2:\n              return [4 /*yield*/, this.streamManager.replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false)];\n            case 3:\n              _b.sent();\n              _b.label = 4;\n            case 4:\n              return [3 /*break*/, 6];\n            case 5:\n              mediaStreamClone.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n              _b.label = 6;\n            case 6:\n              this.virtualBackgroundSinkElements.VB.cleanUp();\n              delete this.virtualBackgroundSinkElements;\n              delete this.virtualBackgroundSourceElements;\n              return [2 /*return*/, resolveRemoveFilter(undefined, false)];\n            case 7:\n              error_3 = _b.sent();\n              return [2 /*return*/, resolveRemoveFilter(error_3, false)];\n            case 8:\n              return [3 /*break*/, 10];\n            case 9:\n              // Server filters\n              if (!this.session.sessionConnected()) {\n                return [2 /*return*/, reject(this.session.notConnectedError())];\n              }\n              logger.info('Removing filter of stream ' + this.streamId);\n              this.session.openvidu.sendRequest('removeFilter', {\n                streamId: this.streamId\n              }, function (error, response) {\n                return resolveRemoveFilter(error, true);\n              });\n              _b.label = 10;\n            case 10:\n              return [3 /*break*/, 12];\n            case 11:\n              // There is no filter applied\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'Stream ' + this.streamId + ' has no filter applied'))];\n            case 12:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setMediaStream = function (mediaStream) {\n    this.mediaStream = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.updateMediaStreamInVideos = function () {\n    this.ee.emitEvent('mediastream-updated', []);\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getWebRtcPeer = function () {\n    return this.webRtcPeer;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.subscribeToMyRemote = function (value) {\n    this.isSubscribeToRemote = value;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setOutboundStreamOptions = function (outboundStreamOpts) {\n    this.outboundStreamOpts = outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.subscribe = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.initWebRtcPeerReceive(false).then(function () {\n        return resolve();\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.publish = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocalStreamReadyToPublish) {\n        _this.initWebRtcPeerSend(false).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        _this.ee.once('stream-ready-to-publish', function () {\n          _this.publish().then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disposeWebRtcPeer = function () {\n    var webrtcId;\n    if (!!this.webRtcPeer) {\n      this.webRtcPeer.dispose();\n      webrtcId = this.webRtcPeer.getId();\n    }\n    this.stopWebRtcStats();\n    logger.info((!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') + 'RTCPeerConnection with id [' + webrtcId + \"] from 'Stream' with id [\" + this.streamId + '] is now closed');\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disposeMediaStream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(!!this.filter && this.filter.type.startsWith('VB:'))) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.removeFilterAux(true)];\n          case 2:\n            _a.sent();\n            console.debug(\"Success removing Virtual Background filter for stream \".concat(this.streamId));\n            return [3 /*break*/, 4];\n          case 3:\n            error_4 = _a.sent();\n            console.error(\"Error removing Virtual Background filter for stream \".concat(this.streamId), error_4);\n            return [3 /*break*/, 4];\n          case 4:\n            if (this.mediaStream) {\n              this.mediaStream.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.mediaStream;\n            }\n            // If subscribeToRemote local MediaStream must be stopped\n            if (this.localMediaStreamWhenSubscribedToRemote) {\n              this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.localMediaStreamWhenSubscribedToRemote;\n            }\n            if (!!this.speechEvent) {\n              if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n              }\n              delete this.speechEvent;\n            }\n            logger.info((!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed');\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.displayMyRemote = function () {\n    return this.isSubscribeToRemote;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendAudio = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.audioSource !== null && this.outboundStreamOpts.publisherProperties.audioSource !== false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendVideo = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.videoSource !== null && this.outboundStreamOpts.publisherProperties.videoSource !== false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendScreen = function () {\n    var screen = false;\n    if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n      var trackSettings = this.outboundStreamOpts.publisherProperties.videoSource.getSettings();\n      if (trackSettings.displaySurface) {\n        screen = [\"monitor\", \"window\", \"browser\"].includes(trackSettings.displaySurface);\n      }\n    }\n    if (!screen && platform.isElectron()) {\n      screen = typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' && this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n    }\n    if (!screen) {\n      screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n    }\n    return !!this.outboundStreamOpts && screen;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n      this.harkSpeakingEnabled = true;\n      this.speechEvent.on('speaking', function () {\n        _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        _this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = true;\n      this.speechEvent.once('speaking', function () {\n        if (_this.harkSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n          _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        }\n        _this.disableHarkSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkSpeakingEnabled) {\n          // The 'on' version of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkSpeakingEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabled = true;\n      this.speechEvent.on('stopped_speaking', function () {\n        _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        _this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = true;\n      this.speechEvent.once('stopped_speaking', function () {\n        if (_this.harkStoppedSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n          _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        }\n        _this.disableHarkStoppedSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkStoppedSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkStoppedSpeakingEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkStoppedSpeakingEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('stopped_speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabled || force) {\n        this.harkVolumeChangeEnabled = true;\n        this.speechEvent.on('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabled = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabledOnce || force) {\n        this.harkVolumeChangeEnabledOnce = true;\n        this.speechEvent.once('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n          _this.disableHarkVolumeChangeEvent(true);\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabledOnce = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkVolumeChangeEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkVolumeChangeEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkVolumeChangeEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkVolumeChangeEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('volume_change');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isLocal = function () {\n    // inbound options undefined and outbound options defined\n    return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getSelectedIceCandidate = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.webRtcStats.getSelectedIceCandidateInfo().then(function (report) {\n        return resolve(report);\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getRemoteIceCandidateList = function () {\n    return this.webRtcPeer.remoteCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getLocalIceCandidateList = function () {\n    return this.webRtcPeer.localCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.streamIceConnectionStateBroken = function () {\n    if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n      return false;\n    }\n    if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n      logger.warn(\"OpenVidu Browser advanced configuration option \\\"forceMediaReconnectionAfterNetworkDrop\\\" is enabled. Stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") will force a reconnection\"));\n      return true;\n    }\n    var iceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n    return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n  };\n  /* Private methods */\n  Stream.prototype.setHarkListenerIfNotExists = function () {\n    if (!!this.mediaStream) {\n      if (!this.speechEvent) {\n        var harkOptions = !!this.harkOptions ? this.harkOptions : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n        harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n        harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n        this.speechEvent = hark(this.mediaStream, harkOptions);\n      }\n      return true;\n    }\n    return false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setupReconnectionEventEmitter = function (resolve, reject) {\n    if (this.reconnectionEventEmitter == undefined) {\n      // There is no ongoing reconnection\n      this.reconnectionEventEmitter = new EventEmitter();\n      return false;\n    } else {\n      // Ongoing reconnection\n      console.warn(\"Trying to reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but an ongoing reconnection process is active. Waiting for response...\"));\n      this.reconnectionEventEmitter.once('success', function () {\n        return resolve();\n      });\n      this.reconnectionEventEmitter.once('error', function (error) {\n        return reject(error);\n      });\n      return true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerSend = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var _a;\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      } else {\n        // MediaStream will already have hark events for reconnected streams\n        _this.initHarkEvents(); // Init hark events for the local stream\n      }\n\n      var finalResolve = function () {\n        var _a;\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n          delete _this.reconnectionEventEmitter;\n        }\n        return resolve();\n      };\n      var finalReject = function (error) {\n        var _a;\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n          delete _this.reconnectionEventEmitter;\n        }\n        return reject(error);\n      };\n      var successOfferCallback = function (sdpOfferParam) {\n        logger.debug('Sending SDP offer to publish as ' + _this.streamId, sdpOfferParam);\n        var method = reconnect ? 'reconnectStream' : 'publishVideo';\n        var params;\n        if (reconnect) {\n          params = {\n            stream: _this.streamId,\n            sdpString: sdpOfferParam\n          };\n        } else {\n          var typeOfVideo = void 0;\n          if (_this.isSendVideo()) {\n            typeOfVideo = typeof MediaStreamTrack !== 'undefined' && _this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack ? TypeOfVideo_1.TypeOfVideo.CUSTOM : _this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n          }\n          params = {\n            doLoopback: _this.displayMyRemote() || false,\n            hasAudio: _this.isSendAudio(),\n            hasVideo: _this.isSendVideo(),\n            audioActive: _this.audioActive,\n            videoActive: _this.videoActive,\n            typeOfVideo: typeOfVideo,\n            frameRate: !!_this.frameRate ? _this.frameRate : -1,\n            videoDimensions: JSON.stringify(_this.videoDimensions),\n            filter: _this.outboundStreamOpts.publisherProperties.filter,\n            sdpOffer: sdpOfferParam\n          };\n        }\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            if (error.code === 401) {\n              finalReject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\"));\n            } else {\n              finalReject('Error on publishVideo: ' + JSON.stringify(error));\n            }\n          } else {\n            _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n              _this.streamId = response.id;\n              _this.creationTime = response.createdAt;\n              _this.isLocalStreamPublished = true;\n              _this.publishedOnce = true;\n              if (_this.displayMyRemote()) {\n                _this.localMediaStreamWhenSubscribedToRemote = _this.mediaStream;\n                _this.remotePeerSuccessfullyEstablished(reconnect);\n              }\n              if (reconnect) {\n                _this.ee.emitEvent('stream-reconnected-by-publisher', []);\n              } else {\n                _this.ee.emitEvent('stream-created-by-publisher', []);\n              }\n              _this.initWebRtcStats();\n              logger.info(\"'Publisher' (\" + _this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'published') + ' to session');\n              finalResolve();\n            }).catch(function (error) {\n              finalReject(error);\n            });\n          }\n        });\n      };\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: (_a = _this.outboundStreamOpts.publisherProperties.videoSimulcast) !== null && _a !== void 0 ? _a : _this.session.openvidu.videoSimulcast,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: _this.onIceConnectionStateExceptionHandler.bind(_this),\n        iceServers: _this.getIceServersConf(),\n        mediaStream: _this.mediaStream,\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n      if (_this.session.openvidu.mediaServer !== 'mediasoup') {\n        // Simulcast is only supported by mediasoup\n        config.simulcast = false;\n      }\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n      if (_this.displayMyRemote()) {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendrecv(config);\n      } else {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendonly(config);\n      }\n      _this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + _this.connection.connectionId);\n      _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n        _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n          successOfferCallback(sdpOffer.sdp);\n        }).catch(function (error) {\n          finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n        });\n      }).catch(function (error) {\n        finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.finalResolveForSubscription = function (reconnect, resolve) {\n    var _a;\n    logger.info(\"'Subscriber' (\" + this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'subscribed'));\n    this.remotePeerSuccessfullyEstablished(reconnect);\n    this.initWebRtcStats();\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n      delete this.reconnectionEventEmitter;\n    }\n    return resolve();\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.finalRejectForSubscription = function (reconnect, error, reject) {\n    var _a;\n    logger.error(\"Error for 'Subscriber' (\" + this.streamId + ') while trying to ' + (reconnect ? 'reconnect' : 'subscribe') + ': ' + error.toString());\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n      delete this.reconnectionEventEmitter;\n    }\n    return reject(error);\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceive = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      }\n      if (_this.session.openvidu.mediaServer === 'mediasoup') {\n        // Server initiates negotiation\n        _this.initWebRtcPeerReceiveFromServer(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      } else {\n        // Client initiates negotiation\n        _this.initWebRtcPeerReceiveFromClient(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceiveFromClient = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.completeWebRtcPeerReceive(reconnect, false).then(function (response) {\n        _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceiveFromServer = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Server initiates negotiation\n      _this.session.openvidu.sendRequest('prepareReceiveVideoFrom', {\n        sender: _this.streamId,\n        reconnect: reconnect\n      }, function (error, response) {\n        if (error) {\n          return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n        } else {\n          _this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer).then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.completeWebRtcPeerReceive = function (reconnect, forciblyReconnect, sdpOfferByServer) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      logger.debug(\"'Session.subscribe(Stream)' called\");\n      var sendSdpToServer = function (sdpString) {\n        logger.debug(\"Sending local SDP \".concat(!!sdpOfferByServer ? 'answer' : 'offer', \" to subscribe to \").concat(_this.streamId), sdpString);\n        var method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n        var params = {};\n        params[reconnect ? 'stream' : 'sender'] = _this.streamId;\n        if (!!sdpOfferByServer) {\n          params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n        } else {\n          params['sdpOffer'] = sdpString;\n        }\n        if (reconnect) {\n          params['forciblyReconnect'] = forciblyReconnect;\n        }\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n          } else {\n            return resolve(response);\n          }\n        });\n      };\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: false,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: _this.onIceConnectionStateExceptionHandler.bind(_this),\n        iceServers: _this.getIceServersConf(),\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n      _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerRecvonly(config);\n      _this.webRtcPeer.addIceConnectionStateChangeListener(_this.streamId);\n      if (!!sdpOfferByServer) {\n        _this.webRtcPeer.processRemoteOffer(sdpOfferByServer).then(function () {\n          _this.webRtcPeer.createAnswer().then(function (sdpAnswer) {\n            _this.webRtcPeer.processLocalAnswer(sdpAnswer).then(function () {\n              sendSdpToServer(sdpAnswer.sdp);\n            }).catch(function (error) {\n              return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n            });\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n        });\n      } else {\n        _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n          _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n            sendSdpToServer(sdpOffer.sdp);\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.remotePeerSuccessfullyEstablished = function (reconnect) {\n    if (reconnect && this.mediaStream != null) {\n      // Now we can destroy the existing MediaStream\n      this.disposeMediaStream();\n    }\n    this.mediaStream = new MediaStream();\n    var receiver;\n    for (var _i = 0, _a = this.webRtcPeer.pc.getReceivers(); _i < _a.length; _i++) {\n      receiver = _a[_i];\n      if (!!receiver.track) {\n        this.mediaStream.addTrack(receiver.track);\n      }\n    }\n    logger.debug('Peer remote stream', this.mediaStream);\n    if (!!this.mediaStream) {\n      if (this.streamManager instanceof Subscriber_1.Subscriber) {\n        // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n        if (!!this.mediaStream.getAudioTracks()[0]) {\n          var enabled = reconnect ? this.audioActive : !!this.streamManager.properties.subscribeToAudio;\n          this.mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n        if (!!this.mediaStream.getVideoTracks()[0]) {\n          var enabled = reconnect ? this.videoActive : !!this.videoActive && !!this.streamManager.properties.subscribeToVideo;\n          this.mediaStream.getVideoTracks()[0].enabled = enabled;\n        }\n      }\n      this.updateMediaStreamInVideos();\n      this.initHarkEvents(); // Init hark events for the remote stream\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initHarkEvents = function () {\n    if (!!this.mediaStream.getAudioTracks()[0]) {\n      // Hark events can only be set if audio track is available\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n        this.enableHarkSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkStoppedSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n        this.enableHarkStoppedSpeakingEvent();\n      }\n      if (this.harkVolumeChangeEnabledOnce) {\n        this.enableOnceHarkVolumeChangeEvent(true);\n      }\n      if (this.harkVolumeChangeEnabled) {\n        this.enableHarkVolumeChangeEvent(true);\n      }\n    }\n  };\n  Stream.prototype.onIceConnectionStateExceptionHandler = function (exceptionName, message, data) {\n    switch (exceptionName) {\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED:\n        this.onIceConnectionFailed();\n        break;\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n        this.onIceConnectionDisconnected();\n        break;\n    }\n    this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(this.session, exceptionName, this, message, data)]);\n  };\n  Stream.prototype.onIceConnectionFailed = function () {\n    // Immediately reconnect, as this is a terminal error\n    logger.log(\"[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \")\"));\n    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED);\n  };\n  Stream.prototype.onIceConnectionDisconnected = function () {\n    var _this = this;\n    // Wait to see if the ICE connection is able to reconnect\n    logger.log(\"[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") if not possible\"));\n    var timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n    this.awaitWebRtcPeerConnectionState(timeout).then(function (state) {\n      switch (state) {\n        case 'failed':\n          // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") is now failed after ICE_CONNECTION_DISCONNECTED\"));\n          break;\n        case 'connected':\n        case 'completed':\n          logger.log(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: \").concat(state));\n          break;\n        case 'closed':\n        case 'checking':\n        case 'new':\n        case 'disconnected':\n          // Rest of states\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after \").concat(timeout, \" ms: \").concat(state));\n          _this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n          break;\n      }\n    });\n  };\n  Stream.prototype.reconnectStreamAndLogResultingIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var finalIceStateAfterReconnection, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.reconnectStreamAndReturnIceConnectionState(event)];\n          case 1:\n            finalIceStateAfterReconnection = _a.sent();\n            switch (finalIceStateAfterReconnection) {\n              case 'connected':\n              case 'completed':\n                logger.log(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") successfully reconnected after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n              default:\n                logger.error(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") failed to reconnect after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n            }\n            return [3 /*break*/, 3];\n          case 2:\n            error_5 = _a.sent();\n            logger.error(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after \").concat(event, \": \").concat(error_5));\n            return [3 /*break*/, 3];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndReturnIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timeout, error_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.log(\"[\".concat(event, \"] Reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after event \").concat(event));\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.reconnectStream(event)];\n          case 2:\n            _a.sent();\n            timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return [2 /*return*/, this.awaitWebRtcPeerConnectionState(timeout)];\n          case 3:\n            error_6 = _a.sent();\n            logger.warn(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \"). Reason: \").concat(error_6));\n            return [2 /*return*/, this.awaitWebRtcPeerConnectionState(1)];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.awaitWebRtcPeerConnectionState = function (timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      var state, interval, intervals, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = this.getRTCPeerConnection().iceConnectionState;\n            interval = 150;\n            intervals = Math.ceil(timeout / interval);\n            i = 0;\n            _a.label = 1;\n          case 1:\n            if (!(i < intervals)) return [3 /*break*/, 4];\n            state = this.getRTCPeerConnection().iceConnectionState;\n            if (state === 'connected' || state === 'completed') {\n              return [3 /*break*/, 4];\n            }\n            // Sleep\n            return [4 /*yield*/, new Promise(function (resolve) {\n              return setTimeout(resolve, interval);\n            })];\n          case 2:\n            // Sleep\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            i++;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, state];\n        }\n      });\n    });\n  };\n  Stream.prototype.reconnectStream = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isWsConnected, errorMsg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.isWebsocketConnected(event, 3000)];\n          case 1:\n            isWsConnected = _a.sent();\n            if (isWsConnected) {\n              // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n              logger.log(\"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") and the websocket is opened\"));\n              if (this.isLocal()) {\n                return [2 /*return*/, this.initWebRtcPeerSend(true)];\n              } else {\n                return [2 /*return*/, this.initWebRtcPeerReceive(true)];\n              }\n            } else {\n              errorMsg = \"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but the websocket wasn't opened\");\n              logger.error(errorMsg);\n              throw Error(errorMsg);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.isWebsocketConnected = function (event, msResponseTimeout) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var wsReadyState = _this.session.openvidu.getWsReadyState();\n      if (wsReadyState === 1) {\n        var responseTimeout_1 = setTimeout(function () {\n          console.warn(\"[\".concat(event, \"] Websocket timeout of \").concat(msResponseTimeout, \"ms\"));\n          return resolve(false);\n        }, msResponseTimeout);\n        _this.session.openvidu.sendRequest('echo', {}, function (error, response) {\n          clearTimeout(responseTimeout_1);\n          if (!!error) {\n            console.warn(\"[\".concat(event, \"] Websocket 'echo' returned error: \").concat(error));\n            return resolve(false);\n          } else {\n            return resolve(true);\n          }\n        });\n      } else {\n        console.warn(\"[\".concat(event, \"] Websocket readyState is \").concat(wsReadyState));\n        return resolve(false);\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcStats = function () {\n    this.webRtcStats = new WebRtcStats_1.WebRtcStats(this);\n    this.webRtcStats.initWebRtcStats();\n    //TODO: send common webrtc stats from client to openvidu-server\n    /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n        setInterval(() => {\n            this.gatherStatsForPeer().then(jsonStats => {\n                const body = {\n                    sessionId: this.session.sessionId,\n                    participantPrivateId: this.connection.rpcSessionId,\n                    stats: jsonStats\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                xhr.setRequestHeader('Content-Type', 'application/json');\n                xhr.send(JSON.stringify(body));\n            })\n        }, this.session.openvidu.webrtcStatsInterval * 1000);\n    }*/\n  };\n\n  Stream.prototype.stopWebRtcStats = function () {\n    if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n      this.webRtcStats.stopWebRtcStats();\n    }\n  };\n  Stream.prototype.getIceServersConf = function () {\n    var returnValue;\n    if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n      returnValue = this.session.openvidu.advancedConfiguration.iceServers === 'freeice' ? undefined : this.session.openvidu.advancedConfiguration.iceServers;\n    } else if (this.session.openvidu.iceServers) {\n      returnValue = this.session.openvidu.iceServers;\n    } else {\n      returnValue = undefined;\n    }\n    return returnValue;\n  };\n  Stream.prototype.gatherStatsForPeer = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocal()) {\n        // Publisher stream stats\n        _this.getRTCPeerConnection().getSenders().forEach(function (sender) {\n          return sender.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id;\n                // Common to Chrome, Firefox and Safari\n                if (report.type === 'outbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum;\n                  // Set media type\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesEncoded'] = report.framesEncoded;\n                  }\n                  finalReport['packetsSent'] = report.packetsSent;\n                  finalReport['bytesSent'] = report.bytesSent;\n                }\n                // Only for Chrome and Safari\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                }\n                // Only for Firefox >= 66.0\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      } else {\n        // Subscriber stream stats\n        _this.getRTCPeerConnection().getReceivers().forEach(function (receiver) {\n          return receiver.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id;\n                // Common to Chrome, Firefox and Safari\n                if (report.type === 'inbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum;\n                  // Set media type\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesDecoded'] = report.framesDecoded;\n                  }\n                  finalReport['packetsReceived'] = report.packetsReceived;\n                  finalReport['packetsLost'] = report.packetsLost;\n                  finalReport['jitter'] = report.jitter;\n                  finalReport['bytesReceived'] = report.bytesReceived;\n                }\n                // Only for Chrome and Safari\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                }\n                // Only for Firefox >= 66.0\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n  Stream.prototype.isReportWanted = function (report) {\n    return report.type === 'inbound-rtp' && !this.isLocal() || report.type === 'outbound-rtp' && this.isLocal() || report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0;\n  };\n  return Stream;\n}();\nexports.Stream = Stream;","map":{"version":3,"names":["Filter_1","require","Subscriber_1","WebRtcPeer_1","WebRtcStats_1","ExceptionEvent_1","PublisherSpeakingEvent_1","StreamManagerEvent_1","StreamPropertyChangedEvent_1","OpenViduError_1","TypeOfVideo_1","OpenViduLogger_1","Platform_1","uuid_1","hark","EventEmitter","logger","OpenViduLogger","getInstance","platform","Stream","session","options","_this","isSubscribeToRemote","isLocalStreamReadyToPublish","isLocalStreamPublished","publishedOnce","harkSpeakingEnabled","harkSpeakingEnabledOnce","harkStoppedSpeakingEnabled","harkStoppedSpeakingEnabledOnce","harkVolumeChangeEnabled","harkVolumeChangeEnabledOnce","ee","PlatformUtils","hasOwnProperty","inboundStreamOpts","streamId","id","creationTime","createdAt","hasAudio","hasVideo","audioActive","videoActive","typeOfVideo","undefined","frameRate","videoDimensions","filter","Object","keys","length","lastExecMethod","outboundStreamOpts","isSendAudio","isSendVideo","publisherProperties","publishAudio","publishVideo","MediaStreamTrack","videoSource","TypeOfVideo","CUSTOM","isSendScreen","SCREEN","CAMERA","on","streamManager","updateMediaStream","mediaStream","debug","_a","prototype","reconnect","reconnectStream","applyFilter","type","Promise","resolve","reject","__awaiter","OpenViduError","OpenViduErrorName","GENERIC_ERROR","resolveApplyFilter","error","triggerEvent","code","OPENVIDU_PERMISSION_DENIED","info","oldValue","Filter","stream","emitEvent","StreamPropertyChangedEvent","startsWith","VIRTUAL_BACKGROUND_ERROR","videos","token","openviduToken_1","tokenParams_1","getTokenParams","edition","encodeURIComponent","btoa","afterScriptLoaded_1","v4","mediaStreamClone","clone","videoClone","video","cloneNode","VirtualBackground","SOURCE_VIDEO_PREFIX","srcObject","muted","virtualBackgroundSourceElements","hideHtmlElement","appendHtmlElementToHiddenContainer","play","_b","sent","VB","openviduServerUrl","URL","httpUri","openviduToken","inputVideo","inputResolution","outputFramerate","filteredVideo","backgroundBlur","backgroundImage","Error","virtualBackgroundSinkElements","style","display","remote","replaceTrackInMediaStream","getVideoTracks","replaceTrackAux","error_1","name","message","script","document","createElement","src","onload","error_2","body","appendChild","then","catch","sessionConnected","notConnectedError","optionsString","JSON","stringify","openvidu","sendRequest","response","removeFilter","removeFilterAux","getRTCPeerConnection","webRtcPeer","pc","getMediaStream","isDisposing","resolveRemoveFilter","getTracks","forEach","track","stop","cleanUp","error_3","setMediaStream","updateMediaStreamInVideos","getWebRtcPeer","subscribeToMyRemote","value","setOutboundStreamOptions","subscribe","initWebRtcPeerReceive","publish","initWebRtcPeerSend","once","disposeWebRtcPeer","webrtcId","dispose","getId","stopWebRtcStats","disposeMediaStream","console","concat","error_4","getAudioTracks","localMediaStreamWhenSubscribedToRemote","speechEvent","displayMyRemote","audioSource","screen","trackSettings","getSettings","displaySurface","includes","isElectron","enableHarkSpeakingEvent","setHarkListenerIfNotExists","PublisherSpeakingEvent","connection","enableOnceHarkSpeakingEvent","disableHarkSpeakingEvent","disabledByOnce","off","enableHarkStoppedSpeakingEvent","enableOnceHarkStoppedSpeakingEvent","disableHarkStoppedSpeakingEvent","enableHarkVolumeChangeEvent","force","harkEvent","oldVolumeValue","newValue","StreamManagerEvent","enableOnceHarkVolumeChangeEvent","disableHarkVolumeChangeEvent","isLocal","getSelectedIceCandidate","webRtcStats","getSelectedIceCandidateInfo","report","getRemoteIceCandidateList","remoteCandidatesQueue","getLocalIceCandidateList","localCandidatesQueue","streamIceConnectionStateBroken","advancedConfiguration","forceMediaReconnectionAfterNetworkDrop","warn","iceConnectionState","harkOptions","publisherSpeakingEventsOptions","interval","threshold","setupReconnectionEventEmitter","reconnectionEventEmitter","initHarkEvents","finalResolve","finalReject","successOfferCallback","sdpOfferParam","method","params","sdpString","doLoopback","sdpOffer","processRemoteAnswer","sdpAnswer","remotePeerSuccessfullyEstablished","initWebRtcStats","config","mediaConstraints","audio","simulcast","videoSimulcast","onIceCandidate","sendIceCandidate","bind","onIceConnectionStateException","onIceConnectionStateExceptionHandler","iceServers","getIceServersConf","mediaServer","WebRtcPeerSendrecv","WebRtcPeerSendonly","addIceConnectionStateChangeListener","connectionId","createOffer","processLocalOffer","sdp","finalResolveForSubscription","finalRejectForSubscription","toString","initWebRtcPeerReceiveFromServer","initWebRtcPeerReceiveFromClient","completeWebRtcPeerReceive","sender","forciblyReconnect","sdpOfferByServer","sendSdpToServer","WebRtcPeerRecvonly","processRemoteOffer","createAnswer","processLocalAnswer","MediaStream","receiver","_i","getReceivers","addTrack","Subscriber","enabled","properties","subscribeToAudio","subscribeToVideo","anySpeechEventListenerEnabled","exceptionName","data","ExceptionEventName","ICE_CONNECTION_FAILED","onIceConnectionFailed","ICE_CONNECTION_DISCONNECTED","onIceConnectionDisconnected","ExceptionEvent","log","reconnectStreamAndLogResultingIceConnectionState","timeout","iceConnectionDisconnectedExceptionTimeout","awaitWebRtcPeerConnectionState","state","event","reconnectStreamAndReturnIceConnectionState","finalIceStateAfterReconnection","error_5","error_6","intervals","Math","ceil","i","setTimeout","isWebsocketConnected","isWsConnected","errorMsg","msResponseTimeout","wsReadyState","getWsReadyState","responseTimeout_1","clearTimeout","WebRtcStats","isEnabled","returnValue","gatherStatsForPeer","getSenders","getStats","isReportWanted","finalReport","timestamp","ssrc","firCount","pliCount","nackCount","qpSum","kind","mediaType","indexOf","framesEncoded","packetsSent","bytesSent","totalRoundTripTime","availableOutgoingBitrate","currentRoundTripTime","responsesReceived","framesDecoded","packetsReceived","packetsLost","jitter","bytesReceived","availableIncomingBitrate","nominated","exports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenVidu\\Stream.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Connection } from './Connection';\nimport { Filter } from './Filter';\nimport { Publisher } from './Publisher';\nimport { Session } from './Session';\nimport { StreamManager } from './StreamManager';\nimport { Subscriber } from './Subscriber';\nimport { InboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/InboundStreamOptions';\nimport { OutboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/OutboundStreamOptions';\nimport {\n    WebRtcPeer,\n    WebRtcPeerSendonly,\n    WebRtcPeerRecvonly,\n    WebRtcPeerSendrecv,\n    WebRtcPeerConfiguration\n} from '../OpenViduInternal/WebRtcPeer/WebRtcPeer';\nimport { WebRtcStats } from '../OpenViduInternal/WebRtcStats/WebRtcStats';\nimport { ExceptionEvent, ExceptionEventName } from '../OpenViduInternal/Events/ExceptionEvent';\nimport { PublisherSpeakingEvent } from '../OpenViduInternal/Events/PublisherSpeakingEvent';\nimport { StreamManagerEvent } from '../OpenViduInternal/Events/StreamManagerEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\n\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * @hidden\n */\nimport hark = require('hark');\n/**\n * @hidden\n */\nimport EventEmitter = require('wolfy87-eventemitter');\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\nexport class Stream {\n    /**\n     * The Connection object that is publishing the stream\n     */\n    connection: Connection;\n\n    /**\n     * Frame rate of the video in frames per second. This property is only defined if the {@link Publisher} of\n     * the stream was initialized passing a _frameRate_ property on {@link OpenVidu.initPublisher} method\n     */\n    frameRate?: number;\n\n    /**\n     * Whether the stream has a video track or not\n     */\n    hasVideo: boolean;\n\n    /**\n     * Whether the stream has an audio track or not\n     */\n    hasAudio: boolean;\n\n    /**\n     * Whether the stream has the video track muted or unmuted. If {@link hasVideo} is false, this property is undefined.\n     *\n     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishVideo}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoActive: boolean;\n\n    /**\n     * Whether the stream has the audio track muted or unmuted. If {@link hasAudio} is false, this property is undefined\n     *\n     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishAudio}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    audioActive: boolean;\n\n    /**\n     * Unique identifier of the stream. If the stream belongs to a...\n     * - Subscriber object: property `streamId` is always defined\n     * - Publisher object: property `streamId` is only defined after successful execution of {@link Session.publish}\n     */\n    streamId: string;\n\n    /**\n     * Time when this stream was created in OpenVidu Server (UTC milliseconds). Depending on the owner of this stream:\n     * - Subscriber object: property `creationTime` is always defined\n     * - Publisher object: property `creationTime` is only defined after successful execution of {@link Session.publish}\n     */\n    creationTime: number;\n\n    /**\n     * Can be:\n     * - `\"CAMERA\"`: when the video source comes from a webcam.\n     * - `\"SCREEN\"`: when the video source comes from screen-sharing.\n     * - `\"CUSTOM\"`: when {@link PublisherProperties.videoSource} has been initialized in the Publisher side with a custom MediaStreamTrack when calling {@link OpenVidu.initPublisher}).\n     * - `\"IPCAM\"`: when the video source comes from an IP camera participant instead of a regular participant (see [IP cameras](/en/stable/advanced-features/ip-cameras/)).\n     *\n     * If {@link hasVideo} is false, this property is undefined\n     */\n    typeOfVideo?: keyof typeof TypeOfVideo; // TODO: Change this type to enum TypeOfVideo on the next breaking-change release\n\n    /**\n     * StreamManager object ({@link Publisher} or {@link Subscriber}) in charge of displaying this stream in the DOM\n     */\n    streamManager: StreamManager;\n\n    /**\n     * Width and height in pixels of the encoded video stream. If {@link hasVideo} is false, this property is undefined\n     *\n     * This property may change if the Publisher that is publishing:\n     * - If it is a mobile device, whenever the user rotates the device.\n     * - If it is screen-sharing, whenever the user changes the size of the captured window.\n     *\n     * Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoDimensions: { width: number; height: number };\n\n    /**\n     * **WARNING**: experimental option. This interface may change in the near future\n     *\n     * Filter applied to the Stream. You can apply filters by calling {@link Stream.applyFilter}, execute methods of the applied filter with\n     * {@link Filter.execMethod} and remove it with {@link Stream.removeFilter}. Be aware that the client calling this methods must have the\n     * necessary permissions: the token owned by the client must have been initialized with the appropriated `allowedFilters` array.\n     */\n    filter?: Filter;\n\n    protected webRtcPeer: WebRtcPeer;\n    protected mediaStream?: MediaStream;\n    private webRtcStats: WebRtcStats;\n\n    private isSubscribeToRemote = false;\n\n    private virtualBackgroundSourceElements?: { videoClone: HTMLVideoElement; mediaStreamClone: MediaStream };\n    /**\n     * @hidden\n     */\n    virtualBackgroundSinkElements?: { VB: any; video: HTMLVideoElement };\n\n    /**\n     * @hidden\n     */\n    isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n    isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n    publishedOnce = false;\n    /**\n     * @hidden\n     */\n    session: Session;\n    /**\n     * @hidden\n     */\n    inboundStreamOpts: InboundStreamOptions;\n    /**\n     * @hidden\n     */\n    outboundStreamOpts: OutboundStreamOptions;\n    /**\n     * @hidden\n     */\n    speechEvent: any;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkOptions;\n    /**\n     * @hidden\n     */\n    localMediaStreamWhenSubscribedToRemote?: MediaStream;\n    /**\n     * @hidden\n     */\n    ee = new EventEmitter();\n    /**\n     * @hidden\n     */\n    reconnectionEventEmitter: EventEmitter | undefined;\n    /**\n     * @hidden\n     */\n    lastVideoTrackConstraints: MediaTrackConstraints | boolean | undefined;\n    /**\n     * @hidden\n     */\n    lastVBFilter?: Filter;\n\n    /**\n     * @hidden\n     */\n    constructor(session: Session, options: InboundStreamOptions | OutboundStreamOptions | {}) {\n        platform = PlatformUtils.getInstance();\n        this.session = session;\n\n        if (options.hasOwnProperty('id')) {\n            // InboundStreamOptions: stream belongs to a Subscriber\n            this.inboundStreamOpts = <InboundStreamOptions>options;\n            this.streamId = this.inboundStreamOpts.id;\n            this.creationTime = this.inboundStreamOpts.createdAt;\n            this.hasAudio = this.inboundStreamOpts.hasAudio;\n            this.hasVideo = this.inboundStreamOpts.hasVideo;\n            if (this.hasAudio) {\n                this.audioActive = this.inboundStreamOpts.audioActive;\n            }\n            if (this.hasVideo) {\n                this.videoActive = this.inboundStreamOpts.videoActive;\n                this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n                this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n                this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n            }\n            if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n                if (\n                    !!this.inboundStreamOpts.filter.lastExecMethod &&\n                    Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0\n                ) {\n                    delete this.inboundStreamOpts.filter.lastExecMethod;\n                }\n                this.filter = this.inboundStreamOpts.filter;\n            }\n        } else {\n            // OutboundStreamOptions: stream belongs to a Publisher\n            this.outboundStreamOpts = <OutboundStreamOptions>options;\n\n            this.hasAudio = this.isSendAudio();\n            this.hasVideo = this.isSendVideo();\n\n            if (this.hasAudio) {\n                this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n            }\n            if (this.hasVideo) {\n                this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n                this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n                if (\n                    typeof MediaStreamTrack !== 'undefined' &&\n                    this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack\n                ) {\n                    this.typeOfVideo = TypeOfVideo.CUSTOM;\n                } else {\n                    this.typeOfVideo = this.isSendScreen() ? TypeOfVideo.SCREEN : TypeOfVideo.CAMERA;\n                }\n            }\n            if (!!this.outboundStreamOpts.publisherProperties.filter) {\n                this.filter = this.outboundStreamOpts.publisherProperties.filter;\n            }\n        }\n\n        this.ee.on('mediastream-updated', () => {\n            this.streamManager.updateMediaStream(this.mediaStream!);\n            logger.debug('Video srcObject [' + this.mediaStream?.id + '] updated in stream [' + this.streamId + ']');\n        });\n    }\n\n    /**\n     * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n     * of a new one, that will apply the same properties.\n     *\n     * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n     * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n     */\n    public reconnect(): Promise<void> {\n        return this.reconnectStream('API');\n    }\n\n    /**\n     * Applies an audio/video filter to the stream.\n     *\n     * @param type Type of filter applied. See {@link Filter.type}\n     * @param options Parameters used to initialize the filter. See {@link Filter.options}\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n     */\n    applyFilter(type: string, options: Object): Promise<Filter> {\n        return new Promise(async (resolve, reject) => {\n            if (!!this.filter) {\n                return reject(\n                    new OpenViduError(OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId)\n                );\n            }\n\n            const resolveApplyFilter = (error, triggerEvent) => {\n                if (error) {\n                    logger.error('Error applying filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(\n                            new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\")\n                        );\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully applied on Stream ' + this.streamId);\n                    const oldValue: Filter = this.filter!;\n                    this.filter = new Filter(type, options);\n                    this.filter.stream = this;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter, oldValue, 'applyFilter')\n                        ]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter, oldValue, 'applyFilter')\n                        ]);\n                    }\n                    return resolve(this.filter);\n                }\n            };\n\n            if (type.startsWith('VB:')) {\n                // Client filters\n\n                if (!this.hasVideo) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'The Virtual Background filter requires a video track to be applied'\n                        )\n                    );\n                }\n                if (!this.mediaStream || this.streamManager.videos.length === 0) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'\n                        )\n                    );\n                }\n\n                let openviduToken: string;\n                if (!!this.session.token) {\n                    openviduToken = this.session.token;\n                } else {\n                    openviduToken = options['token'];\n                }\n                if (!openviduToken) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'\n                        )\n                    );\n                }\n\n                const tokenParams = this.session.getTokenParams(openviduToken);\n                if (tokenParams.edition !== 'pro' && tokenParams.edition !== 'enterprise') {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'\n                        )\n                    );\n                }\n\n                openviduToken = encodeURIComponent(btoa(openviduToken));\n\n                logger.info('Applying Virtual Background to stream ' + this.streamId);\n\n                const afterScriptLoaded = async () => {\n                    try {\n                        const id = this.streamId + '_' + uuidv4();\n                        const mediaStreamClone = this.mediaStream!.clone();\n                        const videoClone = this.streamManager.videos[0].video.cloneNode(false) as HTMLVideoElement;\n                        // @ts-ignore\n                        videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                        videoClone.srcObject = mediaStreamClone;\n                        videoClone.muted = true;\n                        this.virtualBackgroundSourceElements = { videoClone, mediaStreamClone };\n\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false);\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n\n                        await videoClone.play();\n\n                        // @ts-ignore\n                        const VB = new VirtualBackground.VirtualBackground({\n                            id,\n                            openviduServerUrl: new URL(tokenParams.httpUri),\n                            openviduToken,\n                            inputVideo: videoClone,\n                            inputResolution: '160x96',\n                            outputFramerate: 24\n                        });\n\n                        let filteredVideo: HTMLVideoElement;\n                        switch (type) {\n                            case 'VB:blur': {\n                                filteredVideo = await VB.backgroundBlur(options);\n                                break;\n                            }\n                            case 'VB:image': {\n                                filteredVideo = await VB.backgroundImage(options);\n                                break;\n                            }\n                            default:\n                                throw new Error('Unknown Virtual Background filter: ' + type);\n                        }\n\n                        this.virtualBackgroundSinkElements = { VB, video: filteredVideo };\n\n                        videoClone.style.display = 'none';\n\n                        if (this.streamManager.remote) {\n                            this.streamManager.replaceTrackInMediaStream(\n                                (this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0],\n                                false\n                            );\n                        } else {\n                            (this.streamManager as Publisher).replaceTrackAux(\n                                (this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0],\n                                false\n                            );\n                        }\n\n                        resolveApplyFilter(undefined, false);\n                    } catch (error) {\n                        if (error.name === OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                            resolveApplyFilter(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error.message), false);\n                        } else {\n                            resolveApplyFilter(error, false);\n                        }\n                    }\n                };\n\n                // @ts-ignore\n                if (typeof VirtualBackground === 'undefined') {\n                    let script: HTMLScriptElement = document.createElement('script');\n                    script.type = 'text/javascript';\n                    script.src = tokenParams.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken;\n                    script.onload = async () => {\n                        try {\n                            await afterScriptLoaded();\n                            resolve(new Filter(type, options));\n                        } catch (error) {\n                            reject(error);\n                        }\n                    };\n                    document.body.appendChild(script);\n                } else {\n                    afterScriptLoaded()\n                        .then(() => resolve(new Filter(type, options)))\n                        .catch((error) => reject(error));\n                }\n            } else {\n                // Server filters\n\n                if (!this.session.sessionConnected()) {\n                    return reject(this.session.notConnectedError());\n                }\n\n                logger.info('Applying server filter to stream ' + this.streamId);\n                options = options != null ? options : {};\n                let optionsString = options;\n                if (typeof optionsString !== 'string') {\n                    optionsString = JSON.stringify(optionsString);\n                }\n                this.session.openvidu.sendRequest(\n                    'applyFilter',\n                    { streamId: this.streamId, type, options: optionsString },\n                    (error, response) => {\n                        resolveApplyFilter(error, true);\n                    }\n                );\n            }\n        });\n    }\n\n    /**\n     * Removes an audio/video filter previously applied.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n     */\n    async removeFilter(): Promise<void> {\n        return await this.removeFilterAux(false);\n    }\n\n    /**\n     * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n     *\n     * @returns Native RTCPeerConnection Web API object\n     */\n    getRTCPeerConnection(): RTCPeerConnection {\n        return this.webRtcPeer.pc;\n    }\n\n    /**\n     * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n     *\n     * @returns Native MediaStream Web API object\n     */\n    getMediaStream(): MediaStream {\n        return this.mediaStream!;\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    removeFilterAux(isDisposing: boolean): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            const resolveRemoveFilter = (error, triggerEvent) => {\n                if (error) {\n                    delete this.filter;\n                    logger.error('Error removing filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(\n                            new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\")\n                        );\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully removed from Stream ' + this.streamId);\n                    const oldValue = this.filter!;\n                    delete this.filter;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter!, oldValue, 'applyFilter')\n                        ]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter!, oldValue, 'applyFilter')\n                        ]);\n                    }\n                    return resolve();\n                }\n            };\n\n            if (!!this.filter) {\n                // There is a filter applied\n\n                if (this.filter?.type.startsWith('VB:')) {\n                    // Client filters\n\n                    try {\n                        const mediaStreamClone = this.virtualBackgroundSourceElements!.mediaStreamClone;\n                        if (!isDisposing) {\n                            if (this.streamManager.remote) {\n                                this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false);\n                            } else {\n                                await (this.streamManager as Publisher).replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false);\n                            }\n                        } else {\n                            mediaStreamClone.getTracks().forEach((track) => track.stop());\n                        }\n\n                        this.virtualBackgroundSinkElements!.VB.cleanUp();\n\n                        delete this.virtualBackgroundSinkElements;\n                        delete this.virtualBackgroundSourceElements;\n\n                        return resolveRemoveFilter(undefined, false);\n                    } catch (error) {\n                        return resolveRemoveFilter(error, false);\n                    }\n                } else {\n                    // Server filters\n\n                    if (!this.session.sessionConnected()) {\n                        return reject(this.session.notConnectedError());\n                    }\n\n                    logger.info('Removing filter of stream ' + this.streamId);\n                    this.session.openvidu.sendRequest('removeFilter', { streamId: this.streamId }, (error, response) => {\n                        return resolveRemoveFilter(error, true);\n                    });\n                }\n            } else {\n                // There is no filter applied\n                return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, 'Stream ' + this.streamId + ' has no filter applied'));\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    setMediaStream(mediaStream: MediaStream): void {\n        this.mediaStream = mediaStream;\n    }\n\n    /**\n     * @hidden\n     */\n    updateMediaStreamInVideos() {\n        this.ee.emitEvent('mediastream-updated', []);\n    }\n\n    /**\n     * @hidden\n     */\n    getWebRtcPeer(): WebRtcPeer {\n        return this.webRtcPeer;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribeToMyRemote(value: boolean): void {\n        this.isSubscribeToRemote = value;\n    }\n\n    /**\n     * @hidden\n     */\n    setOutboundStreamOptions(outboundStreamOpts: OutboundStreamOptions): void {\n        this.outboundStreamOpts = outboundStreamOpts;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribe(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.initWebRtcPeerReceive(false)\n                .then(() => resolve())\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    publish(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocalStreamReadyToPublish) {\n                this.initWebRtcPeerSend(false)\n                    .then(() => resolve())\n                    .catch((error) => reject(error));\n            } else {\n                this.ee.once('stream-ready-to-publish', () => {\n                    this.publish()\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                });\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    disposeWebRtcPeer(): void {\n        let webrtcId;\n        if (!!this.webRtcPeer) {\n            this.webRtcPeer.dispose();\n            webrtcId = this.webRtcPeer.getId();\n        }\n        this.stopWebRtcStats();\n        logger.info(\n            (!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') +\n            'RTCPeerConnection with id [' +\n            webrtcId +\n            \"] from 'Stream' with id [\" +\n            this.streamId +\n            '] is now closed'\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    async disposeMediaStream(): Promise<void> {\n        if (!!this.filter && this.filter.type.startsWith('VB:')) {\n            try {\n                await this.removeFilterAux(true);\n                console.debug(`Success removing Virtual Background filter for stream ${this.streamId}`);\n            } catch (error) {\n                console.error(`Error removing Virtual Background filter for stream ${this.streamId}`, error);\n            }\n        }\n        if (this.mediaStream) {\n            this.mediaStream.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.mediaStream.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.mediaStream;\n        }\n        // If subscribeToRemote local MediaStream must be stopped\n        if (this.localMediaStreamWhenSubscribedToRemote) {\n            this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.localMediaStreamWhenSubscribedToRemote;\n        }\n        if (!!this.speechEvent) {\n            if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n            }\n            delete this.speechEvent;\n        }\n        logger.info(\n            (!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed'\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    displayMyRemote(): boolean {\n        return this.isSubscribeToRemote;\n    }\n\n    /**\n     * @hidden\n     */\n    isSendAudio(): boolean {\n        return (\n            !!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== null &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== false\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    isSendVideo(): boolean {\n        return (\n            !!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== null &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== false\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    isSendScreen(): boolean {\n        let screen = false\n        if (typeof MediaStreamTrack !== 'undefined' &&\n            this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n            let trackSettings: any = this.outboundStreamOpts.publisherProperties.videoSource.getSettings();\n            if (trackSettings.displaySurface) {\n                screen = [\"monitor\", \"window\", \"browser\"].includes(trackSettings.displaySurface);\n            }\n        }\n        if (!screen && platform.isElectron()) {\n            screen =\n                typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' &&\n                this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n        }\n        if (!screen) {\n            screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n        }\n        return !!this.outboundStreamOpts && screen;\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n            this.harkSpeakingEnabled = true;\n            this.speechEvent.on('speaking', () => {\n                this.session.emitEvent('publisherStartSpeaking', [\n                    new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)\n                ]);\n                this.streamManager.emitEvent('publisherStartSpeaking', [\n                    new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)\n                ]);\n                this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = true;\n            this.speechEvent.once('speaking', () => {\n                if (this.harkSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStartSpeaking', [\n                        new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)\n                    ]);\n                    this.streamManager.emitEvent('publisherStartSpeaking', [\n                        new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)\n                    ]);\n                }\n                this.disableHarkSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkSpeakingEnabled) {\n                    // The 'on' version of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabled = true;\n            this.speechEvent.on('stopped_speaking', () => {\n                this.session.emitEvent('publisherStopSpeaking', [\n                    new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)\n                ]);\n                this.streamManager.emitEvent('publisherStopSpeaking', [\n                    new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)\n                ]);\n                this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = true;\n            this.speechEvent.once('stopped_speaking', () => {\n                if (this.harkStoppedSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStopSpeaking', [\n                        new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)\n                    ]);\n                    this.streamManager.emitEvent('publisherStopSpeaking', [\n                        new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)\n                    ]);\n                }\n                this.disableHarkStoppedSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkStoppedSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkStoppedSpeakingEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkStoppedSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('stopped_speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabled || force) {\n                this.harkVolumeChangeEnabled = true;\n                this.speechEvent.on('volume_change', (harkEvent) => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [\n                        new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)\n                    ]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabled = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabledOnce || force) {\n                this.harkVolumeChangeEnabledOnce = true;\n                this.speechEvent.once('volume_change', (harkEvent) => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.disableHarkVolumeChangeEvent(true);\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [\n                        new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)\n                    ]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabledOnce = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkVolumeChangeEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkVolumeChangeEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkVolumeChangeEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkVolumeChangeEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('volume_change');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    isLocal(): boolean {\n        // inbound options undefined and outbound options defined\n        return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n    }\n\n    /**\n     * @hidden\n     */\n    getSelectedIceCandidate(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.webRtcStats\n                .getSelectedIceCandidateInfo()\n                .then((report) => resolve(report))\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    getRemoteIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.remoteCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    getLocalIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.localCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    streamIceConnectionStateBroken() {\n        if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n            return false;\n        }\n        if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n            logger.warn(\n                `OpenVidu Browser advanced configuration option \"forceMediaReconnectionAfterNetworkDrop\" is enabled. Stream ${this.streamId\n                } (${this.isLocal() ? 'Publisher' : 'Subscriber'}) will force a reconnection`\n            );\n            return true;\n        }\n        const iceConnectionState: RTCIceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n        return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n    }\n\n    /* Private methods */\n\n    private setHarkListenerIfNotExists(): boolean {\n        if (!!this.mediaStream) {\n            if (!this.speechEvent) {\n                const harkOptions = !!this.harkOptions\n                    ? this.harkOptions\n                    : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n                harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n                harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n                this.speechEvent = hark(this.mediaStream, harkOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @hidden\n     */\n    setupReconnectionEventEmitter(resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): boolean {\n        if (this.reconnectionEventEmitter == undefined) {\n            // There is no ongoing reconnection\n            this.reconnectionEventEmitter = new EventEmitter();\n            return false;\n        } else {\n            // Ongoing reconnection\n            console.warn(\n                `Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) but an ongoing reconnection process is active. Waiting for response...`\n            );\n            this.reconnectionEventEmitter.once('success', () => resolve());\n            this.reconnectionEventEmitter.once('error', (error) => reject(error));\n            return true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerSend(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            } else {\n                // MediaStream will already have hark events for reconnected streams\n                this.initHarkEvents(); // Init hark events for the local stream\n            }\n\n            const finalResolve = () => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('success');\n                    delete this.reconnectionEventEmitter;\n                }\n                return resolve();\n            };\n\n            const finalReject = (error) => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('error', [error]);\n                    delete this.reconnectionEventEmitter;\n                }\n                return reject(error);\n            };\n\n            const successOfferCallback = (sdpOfferParam) => {\n                logger.debug('Sending SDP offer to publish as ' + this.streamId, sdpOfferParam);\n\n                const method = reconnect ? 'reconnectStream' : 'publishVideo';\n                let params;\n                if (reconnect) {\n                    params = {\n                        stream: this.streamId,\n                        sdpString: sdpOfferParam\n                    };\n                } else {\n                    let typeOfVideo;\n                    if (this.isSendVideo()) {\n                        typeOfVideo =\n                            typeof MediaStreamTrack !== 'undefined' &&\n                                this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack\n                                ? TypeOfVideo.CUSTOM\n                                : this.isSendScreen()\n                                    ? TypeOfVideo.SCREEN\n                                    : TypeOfVideo.CAMERA;\n                    }\n                    params = {\n                        doLoopback: this.displayMyRemote() || false,\n                        hasAudio: this.isSendAudio(),\n                        hasVideo: this.isSendVideo(),\n                        audioActive: this.audioActive,\n                        videoActive: this.videoActive,\n                        typeOfVideo,\n                        frameRate: !!this.frameRate ? this.frameRate : -1,\n                        videoDimensions: JSON.stringify(this.videoDimensions),\n                        filter: this.outboundStreamOpts.publisherProperties.filter,\n                        sdpOffer: sdpOfferParam\n                    };\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        if (error.code === 401) {\n                            finalReject(\n                                new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\")\n                            );\n                        } else {\n                            finalReject('Error on publishVideo: ' + JSON.stringify(error));\n                        }\n                    } else {\n                        this.webRtcPeer\n                            .processRemoteAnswer(response.sdpAnswer)\n                            .then(() => {\n                                this.streamId = response.id;\n                                this.creationTime = response.createdAt;\n                                this.isLocalStreamPublished = true;\n                                this.publishedOnce = true;\n                                if (this.displayMyRemote()) {\n                                    this.localMediaStreamWhenSubscribedToRemote = this.mediaStream;\n                                    this.remotePeerSuccessfullyEstablished(reconnect);\n                                }\n                                if (reconnect) {\n                                    this.ee.emitEvent('stream-reconnected-by-publisher', []);\n                                } else {\n                                    this.ee.emitEvent('stream-created-by-publisher', []);\n                                }\n                                this.initWebRtcStats();\n                                logger.info(\n                                    \"'Publisher' (\" +\n                                    this.streamId +\n                                    ') successfully ' +\n                                    (reconnect ? 'reconnected' : 'published') +\n                                    ' to session'\n                                );\n\n                                finalResolve();\n                            })\n                            .catch((error) => {\n                                finalReject(error);\n                            });\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo\n                },\n                simulcast: this.outboundStreamOpts.publisherProperties.videoSimulcast ?? this.session.openvidu.videoSimulcast,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: this.onIceConnectionStateExceptionHandler.bind(this),\n                iceServers: this.getIceServersConf(),\n                mediaStream: this.mediaStream,\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined\n            };\n\n            if (this.session.openvidu.mediaServer !== 'mediasoup') {\n                // Simulcast is only supported by mediasoup\n                config.simulcast = false;\n            }\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n            if (this.displayMyRemote()) {\n                this.webRtcPeer = new WebRtcPeerSendrecv(config);\n            } else {\n                this.webRtcPeer = new WebRtcPeerSendonly(config);\n            }\n            this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + this.connection.connectionId);\n            this.webRtcPeer\n                .createOffer()\n                .then((sdpOffer) => {\n                    this.webRtcPeer\n                        .processLocalOffer(sdpOffer)\n                        .then(() => {\n                            successOfferCallback(sdpOffer.sdp);\n                        })\n                        .catch((error) => {\n                            finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n                        });\n                })\n                .catch((error) => {\n                    finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n                });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    finalResolveForSubscription(reconnect: boolean, resolve: (value: void | PromiseLike<void>) => void) {\n        logger.info(\"'Subscriber' (\" + this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'subscribed'));\n        this.remotePeerSuccessfullyEstablished(reconnect);\n        this.initWebRtcStats();\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('success');\n            delete this.reconnectionEventEmitter;\n        }\n        return resolve();\n    }\n\n    /**\n     * @hidden\n     */\n    finalRejectForSubscription(reconnect: boolean, error: any, reject: (reason?: any) => void) {\n        logger.error(\n            \"Error for 'Subscriber' (\" +\n            this.streamId +\n            ') while trying to ' +\n            (reconnect ? 'reconnect' : 'subscribe') +\n            ': ' +\n            error.toString()\n        );\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('error', [error]);\n            delete this.reconnectionEventEmitter;\n        }\n        return reject(error);\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceive(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            }\n\n            if (this.session.openvidu.mediaServer === 'mediasoup') {\n                // Server initiates negotiation\n\n                this.initWebRtcPeerReceiveFromServer(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch((error) => this.finalRejectForSubscription(reconnect, error, reject));\n            } else {\n                // Client initiates negotiation\n\n                this.initWebRtcPeerReceiveFromClient(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch((error) => this.finalRejectForSubscription(reconnect, error, reject));\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromClient(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.completeWebRtcPeerReceive(reconnect, false)\n                .then((response) => {\n                    this.webRtcPeer\n                        .processRemoteAnswer(response.sdpAnswer)\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                })\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromServer(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            // Server initiates negotiation\n            this.session.openvidu.sendRequest('prepareReceiveVideoFrom', { sender: this.streamId, reconnect }, (error, response) => {\n                if (error) {\n                    return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n                } else {\n                    this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer)\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                }\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    completeWebRtcPeerReceive(reconnect: boolean, forciblyReconnect: boolean, sdpOfferByServer?: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            logger.debug(\"'Session.subscribe(Stream)' called\");\n\n            const sendSdpToServer = (sdpString: string) => {\n                logger.debug(`Sending local SDP ${!!sdpOfferByServer ? 'answer' : 'offer'} to subscribe to ${this.streamId}`, sdpString);\n\n                const method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n                const params = {};\n                params[reconnect ? 'stream' : 'sender'] = this.streamId;\n                if (!!sdpOfferByServer) {\n                    params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n                } else {\n                    params['sdpOffer'] = sdpString;\n                }\n                if (reconnect) {\n                    params['forciblyReconnect'] = forciblyReconnect;\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n                    } else {\n                        return resolve(response);\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo\n                },\n                simulcast: false,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: this.onIceConnectionStateExceptionHandler.bind(this),\n                iceServers: this.getIceServersConf(),\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined\n            };\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n\n            this.webRtcPeer = new WebRtcPeerRecvonly(config);\n            this.webRtcPeer.addIceConnectionStateChangeListener(this.streamId);\n\n            if (!!sdpOfferByServer) {\n                this.webRtcPeer\n                    .processRemoteOffer(sdpOfferByServer)\n                    .then(() => {\n                        this.webRtcPeer\n                            .createAnswer()\n                            .then((sdpAnswer) => {\n                                this.webRtcPeer\n                                    .processLocalAnswer(sdpAnswer)\n                                    .then(() => {\n                                        sendSdpToServer(sdpAnswer.sdp!);\n                                    })\n                                    .catch((error) => {\n                                        return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n                                    });\n                            })\n                            .catch((error) => {\n                                return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n                            });\n                    })\n                    .catch((error) => {\n                        return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n                    });\n            } else {\n                this.webRtcPeer\n                    .createOffer()\n                    .then((sdpOffer) => {\n                        this.webRtcPeer\n                            .processLocalOffer(sdpOffer)\n                            .then(() => {\n                                sendSdpToServer(sdpOffer.sdp!);\n                            })\n                            .catch((error) => {\n                                return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n                            });\n                    })\n                    .catch((error) => {\n                        return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n                    });\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    remotePeerSuccessfullyEstablished(reconnect: boolean): void {\n        if (reconnect && this.mediaStream != null) {\n            // Now we can destroy the existing MediaStream\n            this.disposeMediaStream();\n        }\n\n        this.mediaStream = new MediaStream();\n        let receiver: RTCRtpReceiver;\n        for (receiver of this.webRtcPeer.pc.getReceivers()) {\n            if (!!receiver.track) {\n                this.mediaStream.addTrack(receiver.track);\n            }\n        }\n        logger.debug('Peer remote stream', this.mediaStream);\n\n        if (!!this.mediaStream) {\n            if (this.streamManager instanceof Subscriber) {\n                // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n                if (!!this.mediaStream.getAudioTracks()[0]) {\n                    const enabled = reconnect ? this.audioActive : !!(this.streamManager as Subscriber).properties.subscribeToAudio;\n                    this.mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!this.mediaStream.getVideoTracks()[0]) {\n                    const enabled = reconnect ? this.videoActive : !!this.videoActive && !!(this.streamManager as Subscriber).properties.subscribeToVideo;\n                    this.mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n            }\n\n            this.updateMediaStreamInVideos();\n            this.initHarkEvents(); // Init hark events for the remote stream\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initHarkEvents(): void {\n        if (!!this.mediaStream!.getAudioTracks()[0]) {\n            // Hark events can only be set if audio track is available\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n                this.enableHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkStoppedSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n                this.enableHarkStoppedSpeakingEvent();\n            }\n            if (this.harkVolumeChangeEnabledOnce) {\n                this.enableOnceHarkVolumeChangeEvent(true);\n            }\n            if (this.harkVolumeChangeEnabled) {\n                this.enableHarkVolumeChangeEvent(true);\n            }\n        }\n    }\n\n    private onIceConnectionStateExceptionHandler(exceptionName: ExceptionEventName, message: string, data?: any): void {\n        switch (exceptionName) {\n            case ExceptionEventName.ICE_CONNECTION_FAILED:\n                this.onIceConnectionFailed();\n                break;\n            case ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n                this.onIceConnectionDisconnected();\n                break;\n        }\n        this.session.emitEvent('exception', [new ExceptionEvent(this.session, exceptionName, this, message, data)]);\n    }\n\n    private onIceConnectionFailed() {\n        // Immediately reconnect, as this is a terminal error\n        logger.log(\n            `[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n            })`\n        );\n        this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_FAILED);\n    }\n\n    private onIceConnectionDisconnected() {\n        // Wait to see if the ICE connection is able to reconnect\n        logger.log(\n            `[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream ${this.streamId\n            } (${this.isLocal() ? 'Publisher' : 'Subscriber'}) if not possible`\n        );\n        const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n        this.awaitWebRtcPeerConnectionState(timeout).then((state) => {\n            switch (state) {\n                case 'failed':\n                    // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n                    logger.warn(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) is now failed after ICE_CONNECTION_DISCONNECTED`\n                    );\n                    break;\n                case 'connected':\n                case 'completed':\n                    logger.log(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: ${state}`\n                    );\n                    break;\n                case 'closed':\n                case 'checking':\n                case 'new':\n                case 'disconnected':\n                    // Rest of states\n                    logger.warn(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after ${timeout} ms: ${state}`\n                    );\n                    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n                    break;\n            }\n        });\n    }\n\n    private async reconnectStreamAndLogResultingIceConnectionState(event: string) {\n        try {\n            const finalIceStateAfterReconnection = await this.reconnectStreamAndReturnIceConnectionState(event);\n            switch (finalIceStateAfterReconnection) {\n                case 'connected':\n                case 'completed':\n                    logger.log(\n                        `[${event}] Stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) successfully reconnected after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`\n                    );\n                    break;\n                default:\n                    logger.error(\n                        `[${event}] Stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) failed to reconnect after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`\n                    );\n                    break;\n            }\n        } catch (error) {\n            logger.error(\n                `[${event}] Error reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) after ${event}: ${error}`\n            );\n        }\n    }\n\n    private async reconnectStreamAndReturnIceConnectionState(event: string): Promise<RTCIceConnectionState> {\n        logger.log(`[${event}] Reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'}) after event ${event}`);\n        try {\n            await this.reconnectStream(event);\n            const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return this.awaitWebRtcPeerConnectionState(timeout);\n        } catch (error) {\n            logger.warn(\n                `[${event}] Error reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'}). Reason: ${error}`\n            );\n            return this.awaitWebRtcPeerConnectionState(1);\n        }\n    }\n\n    private async awaitWebRtcPeerConnectionState(timeout: number): Promise<RTCIceConnectionState> {\n        let state = this.getRTCPeerConnection().iceConnectionState;\n        const interval = 150;\n        const intervals = Math.ceil(timeout / interval);\n        for (let i = 0; i < intervals; i++) {\n            state = this.getRTCPeerConnection().iceConnectionState;\n            if (state === 'connected' || state === 'completed') {\n                break;\n            }\n            // Sleep\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n        return state;\n    }\n\n    private async reconnectStream(event: string) {\n        const isWsConnected = await this.isWebsocketConnected(event, 3000);\n        if (isWsConnected) {\n            // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n            logger.log(\n                `[${event}] Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) and the websocket is opened`\n            );\n            if (this.isLocal()) {\n                return this.initWebRtcPeerSend(true);\n            } else {\n                return this.initWebRtcPeerReceive(true);\n            }\n        } else {\n            // There is no connection to openvidu-server. Nothing can be done. The automatic reconnection\n            // feature should handle a possible reconnection of RTCPeerConnection in case network comes back\n            const errorMsg = `[${event}] Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) but the websocket wasn't opened`;\n            logger.error(errorMsg);\n            throw Error(errorMsg);\n        }\n    }\n\n    private isWebsocketConnected(event: string, msResponseTimeout: number): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            const wsReadyState = this.session.openvidu.getWsReadyState();\n            if (wsReadyState === 1) {\n                const responseTimeout = setTimeout(() => {\n                    console.warn(`[${event}] Websocket timeout of ${msResponseTimeout}ms`);\n                    return resolve(false);\n                }, msResponseTimeout);\n                this.session.openvidu.sendRequest('echo', {}, (error, response) => {\n                    clearTimeout(responseTimeout);\n                    if (!!error) {\n                        console.warn(`[${event}] Websocket 'echo' returned error: ${error}`);\n                        return resolve(false);\n                    } else {\n                        return resolve(true);\n                    }\n                });\n            } else {\n                console.warn(`[${event}] Websocket readyState is ${wsReadyState}`);\n                return resolve(false);\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcStats(): void {\n        this.webRtcStats = new WebRtcStats(this);\n        this.webRtcStats.initWebRtcStats();\n\n        //TODO: send common webrtc stats from client to openvidu-server\n        /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n            setInterval(() => {\n                this.gatherStatsForPeer().then(jsonStats => {\n                    const body = {\n                        sessionId: this.session.sessionId,\n                        participantPrivateId: this.connection.rpcSessionId,\n                        stats: jsonStats\n                    }\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                    xhr.setRequestHeader('Content-Type', 'application/json');\n                    xhr.send(JSON.stringify(body));\n                })\n            }, this.session.openvidu.webrtcStatsInterval * 1000);\n        }*/\n    }\n\n    private stopWebRtcStats(): void {\n        if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n            this.webRtcStats.stopWebRtcStats();\n        }\n    }\n\n    private getIceServersConf(): RTCIceServer[] | undefined {\n        let returnValue;\n        if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n            returnValue =\n                this.session.openvidu.advancedConfiguration.iceServers === 'freeice'\n                    ? undefined\n                    : this.session.openvidu.advancedConfiguration.iceServers;\n        } else if (this.session.openvidu.iceServers) {\n            returnValue = this.session.openvidu.iceServers;\n        } else {\n            returnValue = undefined;\n        }\n        return returnValue;\n    }\n\n    private gatherStatsForPeer(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocal()) {\n                // Publisher stream stats\n\n                this.getRTCPeerConnection()\n                    .getSenders()\n                    .forEach((sender) =>\n                        sender.getStats().then((response) => {\n                            response.forEach((report) => {\n                                if (this.isReportWanted(report)) {\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'outbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesEncoded'] = report.framesEncoded;\n                                        }\n\n                                        finalReport['packetsSent'] = report.packetsSent;\n                                        finalReport['bytesSent'] = report.bytesSent;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n                                    }\n\n                                    logger.log(finalReport);\n                                }\n                            });\n                        })\n                    );\n            } else {\n                // Subscriber stream stats\n\n                this.getRTCPeerConnection()\n                    .getReceivers()\n                    .forEach((receiver) =>\n                        receiver.getStats().then((response) => {\n                            response.forEach((report) => {\n                                if (this.isReportWanted(report)) {\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'inbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesDecoded'] = report.framesDecoded;\n                                        }\n\n                                        finalReport['packetsReceived'] = report.packetsReceived;\n                                        finalReport['packetsLost'] = report.packetsLost;\n                                        finalReport['jitter'] = report.jitter;\n                                        finalReport['bytesReceived'] = report.bytesReceived;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n                                    }\n                                    logger.log(finalReport);\n                                }\n                            });\n                        })\n                    );\n            }\n        });\n    }\n\n    private isReportWanted(report: any): boolean {\n        return (\n            (report.type === 'inbound-rtp' && !this.isLocal()) ||\n            (report.type === 'outbound-rtp' && this.isLocal()) ||\n            (report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0)\n        );\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}