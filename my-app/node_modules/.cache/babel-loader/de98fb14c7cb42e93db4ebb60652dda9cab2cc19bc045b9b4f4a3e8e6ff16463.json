{"ast":null,"code":"'use strict';\n\nvar OpenViduLogger = require('../../../../Logger/OpenViduLogger').OpenViduLogger;\nvar Logger = OpenViduLogger.getInstance();\nvar MAX_RETRIES = 2000;\nvar RETRY_TIME_MS = 3000;\nvar CONNECTING = 0;\nvar OPEN = 1;\nvar CLOSING = 2;\nvar CLOSED = 3;\nfunction WebSocketWithReconnection(config) {\n  var closing = false;\n  var registerMessageHandler;\n  var wsUri = config.uri;\n  var reconnecting = false;\n  var ws = new WebSocket(wsUri);\n  ws.onopen = function () {\n    Logger.debug('WebSocket connected to ' + wsUri);\n    if (config.onconnected) {\n      config.onconnected();\n    }\n  };\n  ws.onerror = function (error) {\n    Logger.error('Could not connect to ' + wsUri + ' (invoking onerror if defined)', error);\n    if (config.onerror) {\n      config.onerror(error);\n    }\n  };\n  var reconnectionOnClose = function () {\n    if (ws.readyState === CLOSED) {\n      if (closing) {\n        Logger.debug('Connection closed by user');\n      } else {\n        if (config.ismasternodecrashed()) {\n          Logger.error('Master Node has crashed. Stopping reconnection process');\n        } else {\n          Logger.debug('Connection closed unexpectedly. Reconnecting...');\n          reconnect(MAX_RETRIES, 1);\n        }\n      }\n    } else {\n      Logger.debug('Close callback from previous websocket. Ignoring it');\n    }\n  };\n  ws.onclose = reconnectionOnClose;\n  function reconnect(maxRetries, numRetries) {\n    Logger.debug('reconnect (attempt #' + numRetries + ', max=' + maxRetries + ')');\n    if (numRetries === 1) {\n      if (reconnecting) {\n        Logger.warn('Trying to reconnect when already reconnecting... Ignoring this reconnection.');\n        return;\n      } else {\n        reconnecting = true;\n      }\n      if (config.onreconnecting) {\n        config.onreconnecting();\n      }\n    }\n    reconnectAux(maxRetries, numRetries);\n  }\n  function addReconnectionQueryParamsIfMissing(uriString) {\n    var searchParams = new URLSearchParams(new URL(uriString).search);\n    if (!searchParams.has('reconnect')) {\n      uriString = Array.from(searchParams).length > 0 ? uriString + '&reconnect=true' : uriString + '?reconnect=true';\n    }\n    return uriString;\n  }\n  function reconnectAux(maxRetries, numRetries) {\n    Logger.debug('Reconnection attempt #' + numRetries);\n    ws.close(4104, 'Connection closed for reconnection');\n    wsUri = addReconnectionQueryParamsIfMissing(wsUri);\n    ws = new WebSocket(wsUri);\n    ws.onopen = function () {\n      Logger.debug('Reconnected to ' + wsUri + ' after ' + numRetries + ' attempts...');\n      reconnecting = false;\n      registerMessageHandler();\n      if (config.onreconnected()) {\n        config.onreconnected();\n      }\n      ws.onclose = reconnectionOnClose;\n    };\n    ws.onerror = function (error) {\n      Logger.warn('Reconnection error: ', error);\n      if (numRetries === maxRetries) {\n        if (config.ondisconnect) {\n          config.ondisconnect();\n        }\n      } else {\n        setTimeout(function () {\n          reconnect(maxRetries, numRetries + 1);\n        }, RETRY_TIME_MS);\n      }\n    };\n  }\n  this.close = function (code, reason) {\n    closing = true;\n    ws.close(code, reason);\n  };\n  this.reconnectWs = function () {\n    Logger.debug('reconnectWs');\n    reconnect(MAX_RETRIES, 1);\n  };\n  this.send = function (message) {\n    ws.send(message);\n  };\n  this.addEventListener = function (type, callback) {\n    registerMessageHandler = function () {\n      ws.addEventListener(type, callback);\n    };\n    registerMessageHandler();\n  };\n  this.getReadyState = function () {\n    return ws.readyState;\n  };\n}\nmodule.exports = WebSocketWithReconnection;","map":{"version":3,"names":["OpenViduLogger","require","Logger","getInstance","MAX_RETRIES","RETRY_TIME_MS","CONNECTING","OPEN","CLOSING","CLOSED","WebSocketWithReconnection","config","closing","registerMessageHandler","wsUri","uri","reconnecting","ws","WebSocket","onopen","debug","onconnected","onerror","error","reconnectionOnClose","readyState","ismasternodecrashed","reconnect","onclose","maxRetries","numRetries","warn","onreconnecting","reconnectAux","addReconnectionQueryParamsIfMissing","uriString","searchParams","URLSearchParams","URL","search","has","Array","from","length","close","onreconnected","ondisconnect","setTimeout","code","reason","reconnectWs","send","message","addEventListener","type","callback","getReadyState","module","exports"],"sources":["C:\\Users\\SSAFY\\Desktop\\catchpalm\\my-app\\node_modules\\openvidu-browser\\src\\OpenViduInternal\\KurentoUtils\\kurento-jsonrpc\\clients\\transports\\webSocketWithReconnection.js"],"sourcesContent":["/*\n * (C) Copyright 2013-2015 Kurento (http://kurento.org/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar OpenViduLogger = require('../../../../Logger/OpenViduLogger').OpenViduLogger;\nvar Logger = OpenViduLogger.getInstance();\n\nvar MAX_RETRIES = 2000; // Forever...\nvar RETRY_TIME_MS = 3000; // FIXME: Implement exponential wait times...\n\nvar CONNECTING = 0;\nvar OPEN = 1;\nvar CLOSING = 2;\nvar CLOSED = 3;\n\n/*\nconfig = {\nuri : wsUri,\nonconnected : callback method to invoke when connection is successful,\nondisconnect : callback method to invoke when the connection is lost (max retries for reconnecting reached),\nonreconnecting : callback method to invoke when the client is reconnecting,\nonreconnected : callback method to invoke when the client successfully reconnects,\n};\n*/\nfunction WebSocketWithReconnection(config) {\n    var closing = false;\n    var registerMessageHandler;\n    var wsUri = config.uri;\n    var reconnecting = false;\n\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = () => {\n        Logger.debug('WebSocket connected to ' + wsUri);\n        if (config.onconnected) {\n            config.onconnected();\n        }\n    };\n\n    ws.onerror = (error) => {\n        Logger.error('Could not connect to ' + wsUri + ' (invoking onerror if defined)', error);\n        if (config.onerror) {\n            config.onerror(error);\n        }\n    };\n\n    var reconnectionOnClose = () => {\n        if (ws.readyState === CLOSED) {\n            if (closing) {\n                Logger.debug('Connection closed by user');\n            } else {\n                if (config.ismasternodecrashed()) {\n                    Logger.error('Master Node has crashed. Stopping reconnection process');\n                } else {\n                    Logger.debug('Connection closed unexpectedly. Reconnecting...');\n                    reconnect(MAX_RETRIES, 1);\n                }\n            }\n        } else {\n            Logger.debug('Close callback from previous websocket. Ignoring it');\n        }\n    };\n\n    ws.onclose = reconnectionOnClose;\n\n    function reconnect(maxRetries, numRetries) {\n        Logger.debug('reconnect (attempt #' + numRetries + ', max=' + maxRetries + ')');\n        if (numRetries === 1) {\n            if (reconnecting) {\n                Logger.warn('Trying to reconnect when already reconnecting... Ignoring this reconnection.');\n                return;\n            } else {\n                reconnecting = true;\n            }\n            if (config.onreconnecting) {\n                config.onreconnecting();\n            }\n        }\n        reconnectAux(maxRetries, numRetries);\n    }\n\n    function addReconnectionQueryParamsIfMissing(uriString) {\n        var searchParams = new URLSearchParams(new URL(uriString).search);\n        if (!searchParams.has('reconnect')) {\n            uriString = Array.from(searchParams).length > 0 ? uriString + '&reconnect=true' : uriString + '?reconnect=true';\n        }\n        return uriString;\n    }\n\n    function reconnectAux(maxRetries, numRetries) {\n        Logger.debug('Reconnection attempt #' + numRetries);\n        ws.close(4104, 'Connection closed for reconnection');\n\n        wsUri = addReconnectionQueryParamsIfMissing(wsUri);\n        ws = new WebSocket(wsUri);\n\n        ws.onopen = () => {\n            Logger.debug('Reconnected to ' + wsUri + ' after ' + numRetries + ' attempts...');\n            reconnecting = false;\n            registerMessageHandler();\n            if (config.onreconnected()) {\n                config.onreconnected();\n            }\n            ws.onclose = reconnectionOnClose;\n        };\n\n        ws.onerror = (error) => {\n            Logger.warn('Reconnection error: ', error);\n            if (numRetries === maxRetries) {\n                if (config.ondisconnect) {\n                    config.ondisconnect();\n                }\n            } else {\n                setTimeout(() => {\n                    reconnect(maxRetries, numRetries + 1);\n                }, RETRY_TIME_MS);\n            }\n        };\n    }\n\n    this.close = (code, reason) => {\n        closing = true;\n        ws.close(code, reason);\n    };\n\n    this.reconnectWs = () => {\n        Logger.debug('reconnectWs');\n        reconnect(MAX_RETRIES, 1);\n    };\n\n    this.send = (message) => {\n        ws.send(message);\n    };\n\n    this.addEventListener = (type, callback) => {\n        registerMessageHandler = () => {\n            ws.addEventListener(type, callback);\n        };\n        registerMessageHandler();\n    };\n\n    this.getReadyState = () => {\n        return ws.readyState;\n    };\n}\n\nmodule.exports = WebSocketWithReconnection;\n"],"mappings":"AAgBA,YAAY;;AAEZ,IAAIA,cAAc,GAAGC,OAAO,CAAC,mCAAmC,CAAC,CAACD,cAAc;AAChF,IAAIE,MAAM,GAAGF,cAAc,CAACG,WAAW,EAAE;AAEzC,IAAIC,WAAW,GAAG,IAAI;AACtB,IAAIC,aAAa,GAAG,IAAI;AAExB,IAAIC,UAAU,GAAG,CAAC;AAClB,IAAIC,IAAI,GAAG,CAAC;AACZ,IAAIC,OAAO,GAAG,CAAC;AACf,IAAIC,MAAM,GAAG,CAAC;AAWd,SAASC,yBAAyBA,CAACC,MAAM;EACrC,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,sBAAsB;EAC1B,IAAIC,KAAK,GAAGH,MAAM,CAACI,GAAG;EACtB,IAAIC,YAAY,GAAG,KAAK;EAExB,IAAIC,EAAE,GAAG,IAAIC,SAAS,CAACJ,KAAK,CAAC;EAE7BG,EAAE,CAACE,MAAM,GAAG;IACRjB,MAAM,CAACkB,KAAK,CAAC,yBAAyB,GAAGN,KAAK,CAAC;IAC/C,IAAIH,MAAM,CAACU,WAAW,EAAE;MACpBV,MAAM,CAACU,WAAW,EAAE;;EAE5B,CAAC;EAEDJ,EAAE,CAACK,OAAO,GAAG,UAACC,KAAK;IACfrB,MAAM,CAACqB,KAAK,CAAC,uBAAuB,GAAGT,KAAK,GAAG,gCAAgC,EAAES,KAAK,CAAC;IACvF,IAAIZ,MAAM,CAACW,OAAO,EAAE;MAChBX,MAAM,CAACW,OAAO,CAACC,KAAK,CAAC;;EAE7B,CAAC;EAED,IAAIC,mBAAmB,GAAG,SAAAA,CAAA;IACtB,IAAIP,EAAE,CAACQ,UAAU,KAAKhB,MAAM,EAAE;MAC1B,IAAIG,OAAO,EAAE;QACTV,MAAM,CAACkB,KAAK,CAAC,2BAA2B,CAAC;OAC5C,MAAM;QACH,IAAIT,MAAM,CAACe,mBAAmB,EAAE,EAAE;UAC9BxB,MAAM,CAACqB,KAAK,CAAC,wDAAwD,CAAC;SACzE,MAAM;UACHrB,MAAM,CAACkB,KAAK,CAAC,iDAAiD,CAAC;UAC/DO,SAAS,CAACvB,WAAW,EAAE,CAAC,CAAC;;;KAGpC,MAAM;MACHF,MAAM,CAACkB,KAAK,CAAC,qDAAqD,CAAC;;EAE3E,CAAC;EAEDH,EAAE,CAACW,OAAO,GAAGJ,mBAAmB;EAEhC,SAASG,SAASA,CAACE,UAAU,EAAEC,UAAU;IACrC5B,MAAM,CAACkB,KAAK,CAAC,sBAAsB,GAAGU,UAAU,GAAG,QAAQ,GAAGD,UAAU,GAAG,GAAG,CAAC;IAC/E,IAAIC,UAAU,KAAK,CAAC,EAAE;MAClB,IAAId,YAAY,EAAE;QACdd,MAAM,CAAC6B,IAAI,CAAC,8EAA8E,CAAC;QAC3F;OACH,MAAM;QACHf,YAAY,GAAG,IAAI;;MAEvB,IAAIL,MAAM,CAACqB,cAAc,EAAE;QACvBrB,MAAM,CAACqB,cAAc,EAAE;;;IAG/BC,YAAY,CAACJ,UAAU,EAAEC,UAAU,CAAC;EACxC;EAEA,SAASI,mCAAmCA,CAACC,SAAS;IAClD,IAAIC,YAAY,GAAG,IAAIC,eAAe,CAAC,IAAIC,GAAG,CAACH,SAAS,CAAC,CAACI,MAAM,CAAC;IACjE,IAAI,CAACH,YAAY,CAACI,GAAG,CAAC,WAAW,CAAC,EAAE;MAChCL,SAAS,GAAGM,KAAK,CAACC,IAAI,CAACN,YAAY,CAAC,CAACO,MAAM,GAAG,CAAC,GAAGR,SAAS,GAAG,iBAAiB,GAAGA,SAAS,GAAG,iBAAiB;;IAEnH,OAAOA,SAAS;EACpB;EAEA,SAASF,YAAYA,CAACJ,UAAU,EAAEC,UAAU;IACxC5B,MAAM,CAACkB,KAAK,CAAC,wBAAwB,GAAGU,UAAU,CAAC;IACnDb,EAAE,CAAC2B,KAAK,CAAC,IAAI,EAAE,oCAAoC,CAAC;IAEpD9B,KAAK,GAAGoB,mCAAmC,CAACpB,KAAK,CAAC;IAClDG,EAAE,GAAG,IAAIC,SAAS,CAACJ,KAAK,CAAC;IAEzBG,EAAE,CAACE,MAAM,GAAG;MACRjB,MAAM,CAACkB,KAAK,CAAC,iBAAiB,GAAGN,KAAK,GAAG,SAAS,GAAGgB,UAAU,GAAG,cAAc,CAAC;MACjFd,YAAY,GAAG,KAAK;MACpBH,sBAAsB,EAAE;MACxB,IAAIF,MAAM,CAACkC,aAAa,EAAE,EAAE;QACxBlC,MAAM,CAACkC,aAAa,EAAE;;MAE1B5B,EAAE,CAACW,OAAO,GAAGJ,mBAAmB;IACpC,CAAC;IAEDP,EAAE,CAACK,OAAO,GAAG,UAACC,KAAK;MACfrB,MAAM,CAAC6B,IAAI,CAAC,sBAAsB,EAAER,KAAK,CAAC;MAC1C,IAAIO,UAAU,KAAKD,UAAU,EAAE;QAC3B,IAAIlB,MAAM,CAACmC,YAAY,EAAE;UACrBnC,MAAM,CAACmC,YAAY,EAAE;;OAE5B,MAAM;QACHC,UAAU,CAAC;UACPpB,SAAS,CAACE,UAAU,EAAEC,UAAU,GAAG,CAAC,CAAC;QACzC,CAAC,EAAEzB,aAAa,CAAC;;IAEzB,CAAC;EACL;EAEA,IAAI,CAACuC,KAAK,GAAG,UAACI,IAAI,EAAEC,MAAM;IACtBrC,OAAO,GAAG,IAAI;IACdK,EAAE,CAAC2B,KAAK,CAACI,IAAI,EAAEC,MAAM,CAAC;EAC1B,CAAC;EAED,IAAI,CAACC,WAAW,GAAG;IACfhD,MAAM,CAACkB,KAAK,CAAC,aAAa,CAAC;IAC3BO,SAAS,CAACvB,WAAW,EAAE,CAAC,CAAC;EAC7B,CAAC;EAED,IAAI,CAAC+C,IAAI,GAAG,UAACC,OAAO;IAChBnC,EAAE,CAACkC,IAAI,CAACC,OAAO,CAAC;EACpB,CAAC;EAED,IAAI,CAACC,gBAAgB,GAAG,UAACC,IAAI,EAAEC,QAAQ;IACnC1C,sBAAsB,GAAG,SAAAA,CAAA;MACrBI,EAAE,CAACoC,gBAAgB,CAACC,IAAI,EAAEC,QAAQ,CAAC;IACvC,CAAC;IACD1C,sBAAsB,EAAE;EAC5B,CAAC;EAED,IAAI,CAAC2C,aAAa,GAAG;IACjB,OAAOvC,EAAE,CAACQ,UAAU;EACxB,CAAC;AACL;AAEAgC,MAAM,CAACC,OAAO,GAAGhD,yBAAyB"},"metadata":{},"sourceType":"script","externalDependencies":[]}