{"ast":null,"code":"var WildEmitter = require('wildemitter');\nfunction getMaxVolume(analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n  for (var i = 4, ii = fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  }\n  ;\n  return maxVolume;\n}\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function (stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n    smoothing = options.smoothing || 0.1,\n    interval = options.interval || 50,\n    threshold = options.threshold,\n    play = options.play,\n    history = options.history || 10,\n    running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n  var sourceNode, fftBins, analyser;\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n  harker.speaking = false;\n  harker.suspend = function () {\n    return audioContext.suspend();\n  };\n  harker.resume = function () {\n    return audioContext.resume();\n  };\n  Object.defineProperty(harker, 'state', {\n    get: function () {\n      return audioContext.state;\n    }\n  });\n  audioContext.onstatechange = function () {\n    harker.emit('state_change', audioContext.state);\n  };\n  harker.setThreshold = function (t) {\n    threshold = t;\n  };\n  harker.setInterval = function (i) {\n    interval = i;\n  };\n  harker.stop = function () {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n    harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function () {\n    setTimeout(function () {\n      //check if stop has been called\n      if (!running) {\n        return;\n      }\n      var currentVolume = getMaxVolume(analyser, fftBins);\n      harker.emit('volume_change', currentVolume, threshold);\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n      looper();\n    }, interval);\n  };\n  looper();\n  return harker;\n};","map":{"version":3,"names":["WildEmitter","require","getMaxVolume","analyser","fftBins","maxVolume","Infinity","getFloatFrequencyData","i","ii","length","audioContextType","window","AudioContext","webkitAudioContext","audioContext","module","exports","stream","options","harker","smoothing","interval","threshold","play","history","running","sourceNode","createAnalyser","fftSize","smoothingTimeConstant","Float32Array","frequencyBinCount","jquery","HTMLAudioElement","HTMLVideoElement","createMediaElementSource","createMediaStreamSource","connect","destination","speaking","suspend","resume","Object","defineProperty","get","state","onstatechange","emit","setThreshold","t","setInterval","stop","disconnect","speakingHistory","push","looper","setTimeout","currentVolume","shift"],"sources":["C:/Users/SSAFY/Desktop/catchpalm/my-app/node_modules/hark/hark.js"],"sourcesContent":["var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}